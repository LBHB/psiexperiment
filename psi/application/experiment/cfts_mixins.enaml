import logging
log = logging.getLogger(__name__)

import pandas as pd

from enaml.application import deferred_call
from enaml.core.api import Conditional
from enaml.widgets.api import Container, DockItem
from enaml.workbench.api import Extension, PluginManifest
from enaml.workbench.core.api import Command

from psi.context.api import ContextGroup, EnumParameter, Parameter
from psi.controller.api import (Downsample, EpochOutput, ExperimentAction,
                                get_hw_ai_choices, get_hw_ao_choices,
                                IIRFilter)
from psi.controller.calibration.tone import tone_sens
from psi.controller.calibration.api import (chirp_sens, InterpCalibration,
                                            PointCalibration, tone_sens)
from psi.core.enaml.api import DataFrameTable
from psi.data.plots import (ChannelPlot, FFTChannelPlot, FFTContainer,
                            TimeContainer, ViewBox)
from psi.data.sinks.api import BColzStore, DisplayValue, TextStore
from psi.token.api import Cos2Envelope, BandlimitedNoise


enamldef MicrophoneSignalViewMixinManifest(PluginManifest):

    id = 'microphone_signal_view_mixin'

    Extension:
        id = 'plots'
        point = 'psi.data.plots'

        TimeContainer:
            name = 'microphone_plot_container'
            label = 'Microphone signal'
            span = 10
            delay = 0.125

            ViewBox:
                name = 'microphone_view'
                y_min = -0.2
                y_max = 0.2

                ChannelPlot:
                    pen_color = 'k'
                    source_name = 'microphone'

            ViewBox:
                name = 'ttl_view'
                y_min = 0
                y_max = 5

                ChannelPlot:
                    pen_color = 'r'
                    pen_width = 2.5
                    source_name = 'ttl_monitor'
                    decimate_mode = 'mean'


enamldef MicrophoneFFTViewMixinManifest(PluginManifest): manifest:

    id = 'microphone_fft_view_mixin'

    Extension:
        id = manifest.id  + '.plots'
        point = 'psi.data.plots'

        FFTContainer:
            name = 'fft_plot_container'
            label = 'FFT'
            freq_lb = 5
            freq_ub = 50000

            ViewBox:
                y_min = -120
                y_max = 100

                FFTChannelPlot:
                    source_name = 'microphone'
                    pen_color = 'k'
                    time_span = 1


enamldef EEGViewMixinManifest(PluginManifest): manifest:

    id = 'eeg_view_mixin'

    Extension:
        id = 'plots'
        point = 'psi.data.plots'

        TimeContainer:
            name = 'trial_plot_container'
            label = 'Trial timing'
            span = 2
            delay = 0.125

            ViewBox:
                name = 'ecg_view'
                y_min = -0.2
                y_max = 0.2

                ChannelPlot:
                    pen_color = 'k'
                    source_name = 'eeg_filtered'


enamldef TemperatureMixinManifest(PluginManifest): manifest:

    id = 'temperature_mixin'

    Extension:
        id = 'temperature_data'
        point = 'psi.data.sinks'

        BColzStore:
            name = 'temperature_store'
            continuous_inputs = ['temperature']

        DisplayValue:
            name = 'temperature_display'
            label = 'Temperature'
            source_name = 'temperature_decimated'

    Extension:
        id = 'temperature_io'
        point = 'psi.controller.io'

        IIRFilter:
            source_name = 'temperature'
            f_lowpass = 0.5
            btype = 'lowpass'
            ftype = 'butter'
            N = 1

            Downsample:
                name = 'temperature_decimated'
                q = 50


def tone_calibrate_channel(event):
    '''
    Calibrate the specified output using the specified input

    Useful for in-ear calibrations. The calibration will be saved.

    Parameters
    ----------
    output_name : string
        Output to calibrate
    input_name : string
        Input to calibrate
    selector_name : string (default='default')
        Selector to use
    parameter_name : string
        Parameter name that contains set of frequencies to calibrate at.
    gain : float
        Gain to set on output channel
    max_thd : {None, float}
        Maximum total harmonic distortion (in percent) to allow. Anything above
        this raises a calibration error.
    min_snr : {None, float}
        Minimum test level (re. noise floor). If the test tone is too close to
        the noise floor, this raises a calibration error.
    duration : float
        Duration of test tone
    iti : float
        Intertrial interval between test tones
    trim : float
        Amount to trim off of start and end of test tone response before
        analysis.
    widget_name : {None, string}
        Name of widget containing results set to update (for viewing).
    attr_name : {None, string}
        Name of attribute on widget to set.
    store_name : {None, string}
        Name of store to write data to.
    '''
    p = event.parameters
    controller = event.workbench.get_plugin('psi.controller')

    # Get a list of planned frequencies
    core = event.workbench.get_plugin('enaml.workbench.core')
    parameter_names = event.parameters.get('parameter_names')
    selector_name = event.parameters.get('selector_name', 'default')

    # Generate a list of frequencies to calibrate for each channel
    ao = {}
    for output_name, parameter_names in p['outputs'].items():
        output = controller.get_output(output_name)
        frequencies = ao.setdefault(output.channel, set())
        for parameter in parameter_names:
            new = core.invoke_command('psi.context.unique_values', \
                                      {'item_name': parameter})
            frequencies.update(new)
    ai = controller.get_input(p['input_name'])

    # Iter through the identified channels and calibrate them
    results = {}
    for ao_channel, frequencies in ao.items():
        # Run the calibration and update the output with that calibration
        result = tone_sens(ao_channel.engine,
                           list(frequencies),
                           gain=p['gain'],
                           ao_channel_name=ao_channel.name,
                           ai_channel_names=[ai.channel.name],
                           max_thd=p['max_thd'],
                           min_snr=p['min_snr'],
                           duration=p['duration'],
                           iti=p['iti'],
                           trim=p['trim'])

        results[ao_channel.name] = result.sort_index()
        log.info('Calibration for channel %s using input %s\n%s',
                 ao_channel.name, ai.name, result)

        result = result.reset_index()
        calibration = PointCalibration(result['frequency'], result['sens'])
        ao_channel.calibration = calibration

    # Merge the calibration data
    results = pd.concat(results.values(), keys=results.keys(), names=['ao_channel'])
    for parameter in ('gain', 'max_thd', 'min_snr'):
        results[parameter] = p[parameter]

    results = results.sort_index().reset_index()

    if p.get('store_name') is not None:
        core = event.workbench.get_plugin('enaml.workbench.core')
        command = '{}.save_dataframe'.format(p['store_name'])
        parameters = {'name': 'tone_calibration', 'dataframe': results}
        core.invoke_command(command, parameters)

    if p.get('widget_name') is not None:
        ui = event.workbench.get_plugin('enaml.workbench.ui')
        widget = ui.window.find(p['widget_name'])
        attr_name = p.get('attr_name')
        deferred_call(setattr, widget, attr_name, results)


def chirp_calibrate_channel(event):
    '''
    Calibrate the specified output using the specified input

    Useful for in-ear calibrations. The calibration will be saved.

    Parameters
    ----------
    output_name : string
        Output to calibrate
    input_name : string
        Input to calibrate
    gain : float
        Gain to set on output channel
    duration : float
        Duration of chirp
    iti : float
        Intertrial interval between chirps
    widget_name : {None, string}
        Name of widget containing results set to update (for viewing).
    attr_name : {None, string}
        Name of attribute on widget to set.
    store_name : {None, string}
        Name of store to write data to.
    '''
    p = event.parameters
    controller = event.workbench.get_plugin('psi.controller')

    # Create a list of channels that need to be calibrated
    ao_channels = set()
    for output_name in p['outputs']:
        output = controller.get_output(output_name)
        ao_channels.update([output.channel])

    ai = controller.get_input(p['input_name'])

    results = {}
    for ao_channel in ao_channels:
        log.debug('Running chirp calibration for %s', ao_channel.name)
        result = chirp_sens(ao_channel.engine,
                            gain=p['gain'],
                            ao_channel_name=ao_channel.name,
                            ai_channel_names=[ai.channel.name],
                            duration=p['duration'],
                            repetitions=p['repetitions'])
        results[ao_channel.name] = result
        calibration = InterpCalibration(result.index, result['sens'])
        ao_channel.calibration = calibration

    results = pd.concat(results.values(), keys=results.keys(),
                        names=['ao_channel'])
    for parameter in ('gain', 'duration', 'repetitions'):
        results[parameter] = p[parameter]

    if p.get('store_name') is not None:
        core = event.workbench.get_plugin('enaml.workbench.core')
        command = '{}.save_dataframe'.format(p['store_name'])
        parameters = {'name': 'chirp_calibration', 'dataframe': results}
        core.invoke_command(command, parameters)


enamldef CalibrationDockItem(DockItem):

    attr result = None

    Container:
        DataFrameTable:
            column_info = {
                'ao_channel': {'label': 'Channel'},
                'frequency': {'label': 'Frequency (Hz)'},
                'snr': {'label': 'SNR (dB)'},
                'thd': {'label': 'THD (%)'},
                'norm_spl': {'label': 'SPL @ 1 Vrms'},
            }
            columns = ['ao_channel', 'frequency', 'norm_spl', 'snr', 'thd']
            data << result


enamldef InEarCalibrationMixinManifest(PluginManifest): manifest:

    id = 'inear_calibration_mixin'

    attr tone_outputs = None
    attr chirp_outputs = None

    Extension:
        id = manifest.id + '.commands'
        point = 'enaml.workbench.core.commands'

        Command:
            id = 'psi.controller.tone_calibrate_channel'
            handler = tone_calibrate_channel
        Command:
            id = 'psi.controller.chirp_calibrate_channel'
            handler = chirp_calibrate_channel

    Extension:
        id = manifest.id + '.calibration_store'
        point = 'psi.data.sinks'

        TextStore:
            name = 'calibration_data'

    Extension:
        id = 'calibration_view'
        point = 'psi.experiment.workspace'

        CalibrationDockItem:
            name = 'calibration_result'
            title = 'Calibration result'

    Extension:
        id = manifest.id + '.actions'
        point = 'psi.controller.actions'

        Conditional:
            condition = manifest.tone_outputs is not None

            ExperimentAction:
                weight = 10
                event = 'experiment_prepare'
                command = 'psi.controller.tone_calibrate_channel'
                kwargs = {
                    'input_name': 'microphone',
                    'outputs': manifest.tone_outputs,
                    'gain': -40,
                    'max_thd': None,
                    'min_snr': 5,
                    'duration': 0.1,
                    'trim': 0.01,
                    'iti': 0,
                    'widget_name': 'calibration_result',
                    'attr_name': 'result',
                    'store_name': 'calibration_data',
                }

        Conditional:
            condition = manifest.chirp_outputs is not None

            ExperimentAction:
                weight = 10
                event = 'experiment_prepare'
                command = 'psi.controller.chirp_calibrate_channel'
                kwargs = {
                    'input_name': 'microphone',
                    'outputs': manifest.chirp_outputs,
                    'gain': -30,
                    'duration': 20e-3,
                    'iti': 1e-3,
                    'repetitions': 16,
                    'widget_name': 'calibration_result',
                    'attr_name': 'result',
                    'store_name': 'calibration_data',
                }


enamldef ABRInEarCalibrationMixinManifest(InEarCalibrationMixinManifest): manifest:

    id = 'abr_inear_calibration_mixin'

    attr tone_outputs = {
        'primary': ['target_tone_frequency'],
    }


enamldef DPOAEInEarCalibrationMixinManifest(InEarCalibrationMixinManifest): manifest:

    id = 'dpoae_inear_calibration_mixin'

    attr chirp_outputs = ['elicitor']

    attr tone_outputs = {
        'primary': ['primary_tone_frequency'],
        'secondary': ['secondary_tone_frequency'],
    }


enamldef DPOAETimeNoiseMixinManifest(PluginManifest): manifest:

    id = 'dpoae_time_noise_mixin'

    attr C

    Extension:
        id = manifest.id + '.commands'
        point = 'enaml.workbench.core.commands'

    Extension:
        id = manifest.id + '.tokens'
        point = 'psi.token.tokens'

        Cos2Envelope: noise:
            name = 'noise_burst'
            label = 'noise burst'
            BandlimitedNoise:
                pass

    Extension:
        id = manifest.id + '.io'
        point = 'psi.controller.io'

        EpochOutput:
            name = 'elicitor'
            label = 'Elicitor settings'
            target_name = C.elicitor_ao_channel
            configurable = False
            token = noise

    Extension:
        id = manifest.id + '.context'
        point = 'psi.context.items'

        ContextGroup:
            name = 'elicitor_timing'
            label = 'Elicitor timing'

            Parameter:
                name = 'elicitor_start'
                label = 'Elicitor start time (sec)'
                dtype = 'float'
                default = 5

            EnumParameter:
                name = 'elicitor_ao_channel'
                label = 'Elicitor speaker channel'
                choices = get_hw_ao_choices(manifest.workbench)
                scope = 'experiment'

            EnumParameter:
                name = 'elicitor_ai_channel'
                label = 'Elicitor microphone channel'
                choices = get_hw_ai_choices(manifest.workbench)
                scope = 'experiment'

    Extension:
        id = manifest.id + '.actions'
        point = 'psi.controller.actions'

        ExperimentAction:
            event = 'dpoae_start'
            command = 'elicitor.start'
            kwargs = {'delay': 'elicitor_start'}
