import logging
log = logging.getLogger(__name__)

import os.path
from atom.api import Typed
import numpy as np
from scipy import signal
from palettable.colorbrewer import qualitative
import itertools
import pyqtgraph as pg
import pandas as pd

from enaml.application import deferred_call
from enaml.workbench.api import Extension
from enaml.workbench.core.api import Command

from psi.context.api import ContextGroup, Parameter, EnumParameter
from psi.context.context_item import OrderedContextMeta
from psi.context.selector import SequenceSelector
from psi.controller.api import ExperimentAction
from psi.controller.calibration.util import psd, psd_freq, db, dbi

from psi.controller.output import SelectorQueuedEpochOutput
from psi.controller.input import ExtractEpochs, Input, Blocked, Accumulate, IIRFilter, Decimate

from psi.controller.base_manifest import (BaseManifest, get_hw_ao_choices,
                                          get_hw_ai_choices)
from psi.controller.calibration.tone import tone_sens

from psi.token.primitives import Chirp

from psi.data.sinks.bcolz_store import BColzStore
from psi.data.sinks.text_store import TextStore

from psi.data.plots import (TimeContainer,
                            ChannelPlot,
                            GroupedEpochAveragePlot,
                            ChannelPlot, ViewBox,
                            FFTContainer,
                            GroupedEpochFFTPlot)


from psi.controller.calibration import FlatCalibration, InterpCalibration
from psi.util import octave_space


def configure_hardware(event):
    '''
    Set the HW AO calibration to attenuation
    '''
    context = event.workbench.get_plugin('psi.context')
    controller = event.workbench.get_plugin('psi.controller')

    # Link up the desired inputs and outputs for the calibration
    values = context.get_values()
    controller.connect_output('hw_ao', values['output_channel'])
    controller.connect_input('pt_hw_ai', values['pt_channel'])
    controller.connect_input('cal_hw_ai', values['cal_channel'])

    # Set the input gains
    pt_channel = controller.get_channel(values['pt_channel'])
    pt_channel.gain = values['pt_input_gain']
    cal_channel = controller.get_channel(values['cal_channel'])
    cal_channel.gain = values['cal_input_gain']

    # Set up the calibration. By setting fixed_gain to the attenuation, this
    # will ensure that the waveform is scaled down to the desired attenuation.
    output_channel = controller.get_channel(values['output_channel'])
    output_channel.calibration = FlatCalibration.as_attenuation()


def calculate_sens(event):
    core = event.workbench.get_plugin('enaml.workbench.core')
    context = event.workbench.get_plugin('psi.context')
    data = event.workbench.get_plugin('psi.data')

    pt_source = data.find_source('pt_epoch')
    cal_source = data.find_source('cal_epoch')
    pt_groups = pt_source.get_epoch_groups(['hw_ao_chirp_level'])
    cal_groups = cal_source.get_epoch_groups(['hw_ao_chirp_level'])

    n = max(len(cal_groups), 3)
    cmap_name = 'Dark2_{}'.format(n)
    cmap = getattr(qualitative, cmap_name)
    colors = itertools.cycle(cmap.colors)

    summaries = []
    keys = []
    for key, color in zip(pt_groups.keys(), colors):
        name = '{}'.format(key)
        sens_summary = calculate_group_sens(pt_source.fs, pt_groups[key],
                                            cal_groups[key], color, context,
                                            data, name)
        sens_summary = pd.DataFrame(sens_summary)
        sens_summary.set_index('frequency', inplace=True)
        summaries.append(sens_summary)
        keys.append(key)

    result = pd.concat(summaries, keys=keys, names=['hw_ao_chirp_level'])
    parameters = {'name': 'chirp_sensitivity', 'dataframe': result}
    core.invoke_command('calibration_data.create_table', parameters=parameters)
    validate_sens(event, result.loc[-37].reset_index())


def calculate_group_sens(fs, pt_waveform, cal_waveform, color, context,
                         data, name):

    cal_mic_sens = context.get_value('cal_mic_sens_mv') * 1e-3
    smoothing_window = context.get_value('smoothing_window')

    freq = psd_freq(pt_waveform, fs)
    pt_psd = np.mean(psd(pt_waveform, fs), axis=0)
    cal_psd = np.mean(psd(cal_waveform, fs), axis=0)

    #pt_psd = pt_summary['psd']
    #cal_psd = cal_summary['psd']
    #pt_phase = pt_summary['phase']
    #cal_phase = cal_summary['phase']

    sens = db(pt_psd) + db(cal_mic_sens) - db(cal_psd)
    #phase = pt_phase - cal_phase
    print(sens)

    if smoothing_window > 0:
        w = signal.hamming(smoothing_window)
        w /= w.sum()
        sens = np.convolve(sens, w, mode='same')
        #phase = np.convolve(phase, w, mode='same')

    pt_summary = {
        'frequency': freq,
        'psd': pt_psd,
    }

    cal_summary = {
        'frequency': freq,
        'psd': cal_psd,
    }

    sens_summary = {
        'frequency': freq,
        'sens': sens,
        #'phase': phase,
    }

    def plot_data(data=data, pt_summary=pt_summary, cal_summary=cal_summary,
                  sens_summary=sens_summary, color=color, name=name):
        vb = data.find_viewbox('pt_fft')
        vb.plot(pt_summary['frequency'], db(pt_summary['psd']), color,
                log_x=True)
        vb = data.find_viewbox('cal_fft')
        vb.plot(cal_summary['frequency'], db(cal_summary['psd']), color,
                log_x=True)
        vb = data.find_viewbox('sens')
        vb.plot(sens_summary['frequency'], sens_summary['sens'], color,
                log_x=True, label=name)

    deferred_call(plot_data)
    return sens_summary


def validate_sens(event, sens):
    controller = event.workbench.get_plugin('psi.controller')
    context = event.workbench.get_plugin('psi.context')
    data = event.workbench.get_plugin('psi.data')
    core = event.workbench.get_plugin('enaml.workbench.core')

    output_channel = context.get_value('output_channel')
    pt_channel = context.get_value('pt_channel')
    cal_channel = context.get_value('cal_channel')
    cal_mic_sens_mv = context.get_value('cal_mic_sens_mv')
    cal_mic_sens = cal_mic_sens_mv*1e-3

    ao = controller.get_channel(output_channel)
    pt_ai = controller.get_channel(pt_channel)
    pt_ai.calibration = FlatCalibration.from_mv_pa(cal_mic_sens_mv)
    cal_ai = controller.get_channel(cal_channel)
    cal_ai.calibration = InterpCalibration(sens['frequency'], sens['sens'])

    freq_lb = context.get_value('hw_ao_chirp_start_frequency')
    freq_ub = context.get_value('hw_ao_chirp_end_frequency')

    frequencies = octave_space(freq_lb*1e-3, freq_ub*1e-3, 0.5)*1e3

    ai_channels = [pt_channel, cal_channel]
    result = tone_sens(ao.engine, frequencies, gain=-50,
                       ao_channel_name=output_channel,
                       ai_channel_names=ai_channels)
    rms = result['rms'].unstack('channel_name')
    pt_rms = rms[pt_channel]
    cal_rms = rms[cal_channel]
    sens = db(pt_rms) + db(cal_mic_sens) - db(cal_rms)

    def plot_data(data=data, sens=sens):
        vb = data.find_viewbox('sens')
        vb.plot(sens.index, sens.values, log_x=True, kind='scatter')

    deferred_call(plot_data)
    parameters = {'name': 'tone_sensitivity', 'dataframe': result}
    core.invoke_command('calibration_data.create_table', parameters=parameters)


enamldef ControllerManifest(BaseManifest): manifest:

    Extension:
        id = 'data'
        point = 'psi.data.sinks'

        BColzStore:
            name = 'bcolz_store'
            continuous_inputs = ['pt_hw_ai', 'cal_hw_ai']
            epoch_inputs = ['pt_epoch', 'cal_epoch']

        TextStore:
            name = 'calibration_data'


    Extension:
        id = 'signals'
        point = 'psi.token.tokens'

        Chirp:
            pass

    Extension:
        id = 'io'
        point = 'psi.controller.io'

        SelectorQueuedEpochOutput: hw_ao:
            name = 'hw_ao'
            auto_decrement = True
            selector_name = 'default'

        # TODO: Come up with a synchronized approach for this?
        Blocked:
            duration = 0.1
            name = 'pt_hw_ai'

            ExtractEpochs:
                queue << hw_ao.queue
                name = 'pt_epoch'

        Blocked:
            duration = 0.1
            name = 'cal_hw_ai'

            ExtractEpochs:
                queue << hw_ao.queue
                name = 'cal_epoch'

    Extension:
        id = 'context'
        point = 'psi.context.items'

        ContextGroup:
            name = 'calibration'
            label = 'Calibration'

            EnumParameter:
                name = 'output_channel'
                label = 'Output channel'
                compact_label = 'ao'
                choices << get_hw_ao_choices(workbench)
                scope = 'experiment'

            EnumParameter:
                name = 'pt_channel'
                label = 'Probe tube mic. channel'
                choices << get_hw_ai_choices(workbench)
                scope = 'experiment'

            Parameter:
                name = 'pt_input_gain'
                label = 'Probe tube input gain (dB)'
                dtype = 'float64'
                default = 20
                scope = 'experiment'

            EnumParameter:
                name = 'cal_channel'
                label = 'Calibration mic. channel'
                choices << get_hw_ai_choices(workbench)
                scope = 'experiment'

            Parameter:
                name = 'cal_input_gain'
                label = 'Calibration input gain (dB)'
                default = 0.0
                scope = 'experiment'

            Parameter:
                name = 'cal_mic_sens_mv'
                label = 'Calibration microphone sensitivity (mV/Pa)'
                default = 0.0
                scope = 'experiment'

            Parameter:
                name = 'smoothing_window'
                label = 'Frequency smoothing window size (bins)'
                default = 25
                scope = 'experiment'

            Parameter:
                name = 'input_range'
                label = 'Expected input range (Vpp)'
                compact_label = 'ai_range'
                dtype = 'float64'
                default = 10
                scope = 'experiment'

        OrderedContextMeta: epoch_groups:
            name = 'settings'

    Extension:
        id = 'selectors'
        point = 'psi.context.selectors'

        SequenceSelector:
            name = 'default'
            label = 'Sequence'


    Extension:
        id = 'calibration_commands'
        point = 'enaml.workbench.core.commands'

        Command:
            id = 'psi.controller.configure_hardware'
            handler = configure_hardware

        Command:
            id = 'psi.controller.calculate_sens'
            handler = calculate_sens

    Extension:
        id = 'actions'
        point = 'psi.controller.actions'

        ExperimentAction:
            event = 'experiment_prepare'
            command = 'psi.controller.configure_hardware'
            weight = 10

        ExperimentAction:
            event = 'experiment_end'
            command = 'psi.controller.calculate_sens'
            weight = 100

        ExperimentAction:
            event = 'cal_epoch_queue_end'
            command = 'psi.controller.stop'

    Extension:
        id = 'plots'
        point = 'psi.data.plots'

        TimeContainer:
            name = 'epoch_container_signal'
            label = 'Epoch average (signal)'
            span = 0.01

            ViewBox:
                y_min = -0.1
                y_max = 0.1
                label = 'Signal (V)'

                GroupedEpochAveragePlot:
                    label = 'PT epoch average plot'
                    source_name = 'pt_epoch'
                    pen_color_cycle = ['k', 'r']
                    groups << epoch_groups

            ViewBox:
                y_min = -0.01
                y_max = 0.01
                label = 'Signal (V)'

                GroupedEpochAveragePlot:
                    label = 'Cal. epoch average plot'
                    source_name = 'cal_epoch'
                    pen_color_cycle = ['k', 'r']
                    groups << epoch_groups

        FFTContainer:
            name = 'epoch_container_psd'
            label = 'Epoch average (PSD)'
            freq_lb = 50.0
            freq_ub = 50000

            ViewBox:
                label = 'Signal (dB re 1V)'
                y_min = -160
                y_max = -50

                GroupedEpochFFTPlot:
                    source_name = 'pt_epoch'
                    pen_color_cycle = ['k', 'r']
                    groups << epoch_groups

            ViewBox:
                label = 'Signal (dB re 1V)'
                y_min = -160
                y_max = -50

                GroupedEpochFFTPlot:
                    source_name = 'cal_epoch'
                    pen_color_cycle = ['k', 'r']
                    groups << epoch_groups

        FFTContainer:
            name = 'calibration_result'
            label = 'Calibration result'
            freq_lb = 50.0
            freq_ub = 50000

            ViewBox:
                y_min = -160
                y_max = -50
                name = 'pt_fft'
                label = 'Probe tube PSD (dB re 1V)'

            ViewBox:
                y_min = -160
                y_max = -50
                name = 'cal_fft'
                label = 'Calibration mic. PSD (dB re 1V)'

            ViewBox:
                name = 'sens'
                label = 'Probe tube sens (V/Pa)'
