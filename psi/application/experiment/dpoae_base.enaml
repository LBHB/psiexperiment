import logging
log = logging.getLogger(__name__)

import numpy as np

from atom.api import Int, Value

from enaml.application import deferred_call
from enaml.core.api import d_
from enaml.widgets.api import Container, DockItem, Label
from enaml.workbench.api import Extension
from enaml.workbench.core.api import Command

from psi.controller.calibration.util import tone_power_conv
from psi.context.api import ContextGroup, OrderedContextMeta, Parameter, Result
from psi.context.selector import CartesianProduct

from psi.controller.api import ExperimentAction
from psi.controller.base_manifest import BaseManifest
from psi.controller.base_plugin import BasePlugin
from psi.controller.input import (Blocked, Capture, ContinuousInput, coroutine,
                                  Discard, Input)

from psi.controller.output import EpochOutput, Synchronized
from psi.token.primitives import Cos2Envelope, Tone

from psi.data.plots import GroupedResultPlot, PlotContainer, ViewBox
from psi.data.sinks.api import BColzStore


@coroutine
def process(n_time, n_fft, input, workbench, status_widget, target):
    context = workbench.get_plugin('psi.context')
    controller = workbench.get_plugin('psi.controller')
    core = workbench.get_plugin('enaml.workbench.core')

    time_data = []
    fft_data = {}
    total_samples = 0

    while True:
        data = (yield)
        time_data.append(data)
        total_samples += data.shape[-1]

        # Process acquired time segments once we have what we need
        if len(time_data) == n_time:
            mean_time = np.mean(time_data, axis=0)
            time_data = []

            f1 = context.get_value('primary_tone_frequency')
            f2 = context.get_value('secondary_tone_frequency')
            noise_floor = context.get_value('max_dpoae_noise_floor')
            dpoae = 2 * f2 - f1

            resolution = input.fs / mean_time.shape[-1]
            nf_frequencies = [f*resolution+dpoae for f in range(-2, 3)]
            frequencies = [f1, f2, dpoae] + nf_frequencies

            rms = tone_power_conv(mean_time, input.fs, frequencies)
            level = input.calibration.get_spl(frequencies, rms)
            nf_level = np.mean(level[3:])
            f1_level, f2_level, dpoae_level = level[:3]

            # If criterion met, store results
            if (nf_level < noise_floor) or (nf_level < dpoae_level):
                fft_data.setdefault('f1_level', []).append(f1_level)
                fft_data.setdefault('f2_level', []).append(f2_level)
                fft_data.setdefault('dpoae_level', []).append(dpoae_level)
                fft_data.setdefault('dpoae_noise_floor', []).append(nf_level)

                # Once we have n_fft, process results
                if len(fft_data['f1_level']) == n_fft:
                    for key in ('f1_level', 'f2_level', 'dpoae_level',
                                'dpoae_noise_floor'):
                        value = np.mean(fft_data[key])
                        context.set_value(key, value)

                    context.set_value('ts_end', controller.get_ts())
                    target([context.get_values()])
                    fft_data = {}

                    # Move to next level
                    # TODO this should be it's own callback
                    #context.next_setting('default')
                    #params = {'timestamp': controller.get_ts(), 'delay': 1}
                    #core.invoke_command('dpoae.start', params)

        # Post current status to the GUI
        def update(n_time, n_fft, status_widget):
            status_widget.n_time = n_time
            status_widget.n_fft = n_fft

        if status_widget is not None:
            nt = len(time_data)
            nf = len(fft_data.get('f1_level', []))
            deferred_call(update, nt, nf, status_widget)


class AnalyzeDPOAE(Input):

    n_fft = d_(Int()).tag(metadata=True)
    n_time = d_(Int()).tag(metadata=True)

    wb = d_(Value())
    status_widget = Value()

    def configure_callback(self):
        cb = super().configure_callback()
        return process(self.n_time, self.n_fft, self, self.wb,
                       self.status_widget, cb).send


def configure_hardware(event):
    context = event.workbench.get_plugin('psi.context')
    controller = event.workbench.get_plugin('psi.controller')

    resp_window = context.get_value('response_window')
    n_time = context.get_value('n_time')
    n_fft = context.get_value('n_fft')
    discard = context.get_value('secondary_tone_rise_time')*2

    ui = event.workbench.get_plugin('enaml.workbench.ui')
    sw = ui.window.find('dpoae_status')

    controller.set_input_attr('discard', 'duration', discard)
    controller.set_input_attr('segment', 'duration', resp_window)
    controller.set_input_attr('analyze_dpoae', 'n_time', n_time)
    controller.set_input_attr('analyze_dpoae', 'n_fft', n_fft)
    controller.set_input_attr('analyze_dpoae', 'status_widget', sw)


enamldef ControllerManifest(BaseManifest): manifest:

    Extension:
        id = 'dpoae_store'
        point = 'psi.data.sinks'

        BColzStore:
            name = 'dpoae_store'
            continuous_inputs = ['microphone']
            table_inputs = ['analyze_dpoae']

    Extension:
        id = 'tokens'
        point = 'psi.token.tokens'

        Cos2Envelope: tone:
            name = 'tone'
            label = 'tone'
            hide = ['start_time']
            Tone:
                hide = ['phase', 'polarity']

    Extension:
        id = 'io'
        point = 'psi.controller.io'

        Synchronized:
            name = 'dpoae'

            EpochOutput: primary:
                name = 'primary'
                label = 'Primary'
                target_name = 'speaker_0'
                configurable = False
                token = tone

            EpochOutput: secondary:
                name = 'secondary'
                label = 'Secondary'
                target_name = 'speaker_1'
                configurable = False
                token = tone

        ContinuousInput:
            name = 'microphone'
            source_name = 'microphone_channel'

            Capture:
                # Begin capturing microphone signal once DPOAE starts.  Linked
                # using an ExperimentAction.
                name = 'dpoae_capture'

                Discard:
                    # Discard the onset portion of the DPOAE (set in
                    # configure_hardware).
                    name = 'discard'

                    Blocked:
                        # Duration (in seconds) of snippets to analyze (set in
                        # configure_hardware)
                        name = 'segment'

                        AnalyzeDPOAE:
                            name = 'analyze_dpoae'
                            wb = workbench

    Extension:
        id = 'selectors'
        point = 'psi.context.selectors'

        CartesianProduct:
            name = 'default'
            label = 'DPOAE'

    Extension:
        id = 'context'
        point = 'psi.context.items'

        ContextGroup:
            name = 'result'
            label = 'Results'
            visible = False

            Result:
                name = 'f2_spl'
                dtype = 'float64'

            Result:
                name = 'f1_spl'
                dtype = 'float64'

            Result:
                name = 'dpoae_spl'
                dtype = 'float64'

            Result:
                name = 'f2_noise_floor'
                dtype = 'float64'

            Result:
                name = 'f1_noise_floor'
                dtype = 'float64'

            Result:
                name = 'dpoae_noise_floor'
                dtype = 'float64'

            Result:
                name = 'ts_end'
                dtype = 'float64'

        ContextGroup:
            name = 'dpoae'
            label = 'DPOAE settings'

            Parameter:
                name = 'n_fft'
                label = 'Spectrum avg. (decr. variablity)'
                compact_label = 'N FFT'
                default = 8

            Parameter:
                name = 'n_time'
                label = 'Time avg. (decr. noise floor)'
                compact_label = 'N time'
                default = 16

            Parameter:
                name = 'max_dpoae_noise_floor'
                label = 'DPOAE noise floor (db SPL)'
                compact_label = 'DPOAE NF'
                dtype = 'float'
                default = 0.0

            Parameter:
                name = 'response_window'
                label = 'Response window (sec)'
                compact_label = 'Resp. Window'
                dtype = 'float'
                default = 100e-3

        OrderedContextMeta: dpoae_groups:
            name = 'dpoae_plot_groups'

    Extension:
        id = 'calibration_commands'
        point = 'enaml.workbench.core.commands'
        Command:
            id = 'psi.controller.configure_hardware'
            handler = configure_hardware

    Extension:
        id = 'actions'
        point = 'psi.controller.actions'

        ExperimentAction:
            event = 'experiment_prepare'
            command = 'psi.context.next_setting'
            weight = 11
            kwargs = {'selector': 'default', 'save_prior': False}

        ExperimentAction:
            event = 'experiment_prepare'
            command = 'psi.controller.configure_hardware'
            weight = 12

        ExperimentAction:
            event = 'engines_configured'
            command = 'dpoae.start'
            kwargs = {'delay': 0.25}

        ExperimentAction:
            event = 'dpoae_start'
            command = 'dpoae_capture.start'
