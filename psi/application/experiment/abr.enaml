import logging
log = logging.getLogger(__name__)

from atom.api import Typed
import numpy as np

from enaml.workbench.api import Extension
from enaml.workbench.core.api import Command

from psi.context.api import ContextGroup, Parameter
from psi.context.selector import CartesianProduct
from psi.controller.api import ExperimentAction
from psi.controller.base_plugin import BasePlugin
from psi.controller.base_manifest import BaseManifest
from psi.controller.input import (ContinuousInput, ExtractEpochs, Input,
                                  Blocked, Accumulate, RejectEpochs, IIRFilter,
                                  Decimate, RMS)
from psi.controller.output import QueuedEpochOutput, EpochOutput
from psi.controller.queue import InterleavedFIFOSignalQueue

from psi.util import copy_declarative

from psi.data.plots import (TimeContainer, ChannelPlot,
                            StackedEpochAveragePlot, ChannelPlot, ViewBox)

from psi.data.sinks.epoch_counter import GroupedEpochCounter

from psi.token.primitives import Cos2Envelope, Tone, BandlimitedNoise


from psi.controller.calibration import FlatCalibration


class ABRController(BasePlugin):

    def start_experiment(self):
        super().start_experiment()
        self.context.next_setting(save_prior=False)
        threshold = self.context.get_value('reject_threshold')
        self.set_input_attr('valid_erp', 'threshold', threshold)


enamldef ControllerManifest(BaseManifest): manifest:

    factory = ABRController

    Extension:
        id = 'tokens'
        point = 'psi.token.tokens'

        # The most standard stimuli
        Cos2Envelope:
            name = 'tone_burst'
            label = 'tone'
            Tone:
                pass

    Extension:
        id = 'io'
        point = 'psi.controller.io'

        ContinuousInput:
            name = 'microphone'
            source_name = 'microphone_channel'
            save = True

            #IIRFilter:
            #    N = 2
            #    name = 'microphone_filtered'
            #    btype = 'highpass'
            #    ftype = 'butter'
            #    f_highpass = 250

            #    RMS:
            #        name = 'microphone_rms'
            #        duration = 5e-3
            #        save = True

        QueuedEpochOutput: output:
            name = 'target'
            label = 'Target'
            target_name = 'speaker_0'
            selector_name = 'default'
            queue = InterleavedFIFOSignalQueue(fs=output.fs, initial_delay=1)
            auto_decrement = False

        Blocked:

            duration = 0.25
            name = 'eeg'
            save = True
            source_name = 'eeg_channel'

            IIRFilter:
                name = 'eeg_filtered'
                N = 2
                btype = 'bandpass'
                ftype = 'butter'
                f_highpass = 300
                f_lowpass = 3000

                Decimate:
                    q = 5
                    name = 'ecg'
                    save = True

                Accumulate:
                    name = 'eeg_buffered'
                    n = 10

                    ExtractEpochs: extract:
                        save = True
                        buffer_size = 50
                        queue = output.queue
                        epoch_size = 8.5e-3
                        name = 'erp'

                        RejectEpochs:
                            save = True
                            name = 'valid_erp'
                            threshold = 2.5

    Extension:
        id = 'context'
        point = 'psi.context.items'

        ContextGroup:
            name = 'abr'
            label = 'ABR settings'

            Parameter:
                name = 'reject_threshold'
                label = 'Reject threshold'
                compact_label = 'Th'
                default = 2.5
                scope = 'experiment'

    Extension:
        id = 'selectors'
        point = 'psi.context.selectors'

        CartesianProduct:
            name = 'default'
            label = 'ABR sequence'

    Extension:
        id = 'actions'
        point = 'psi.controller.actions'
        rank = 100

        ExperimentAction:
            weight = 15
            event = 'experiment_prepare'
            command = 'psi.controller.tone_calibrate_channel'
            kwargs = {
                'input_name': 'microphone',
                'output_name': 'target',
                'parameter_names': ['target_tone_frequency'],
                'gain': -40,
                'max_thd': 2,
                'min_snr': 6,
            }

        ExperimentAction:
            event = 'valid_erp_acquired'
            command = 'target.decrement_key'

        ExperimentAction:
            event = 'target_end'
            command = 'psi.controller.stop'

    Extension:
        id = 'sink'
        point = 'psi.data.sinks'

        GroupedEpochCounter:
            name = 'valid_erp_counter'
            label = 'Valid ERPs acquired'
            source_name = 'valid_erp'

    Extension:
        id = 'plots'
        point = 'psi.data.plots'

        TimeContainer:
            name = 'erp_container'
            label = 'ERP average'
            span = 8.5e-3

            ViewBox:
                y_min = -0.1
                y_max = 0.1
                label = 'Signal (V)'

                StackedEpochAveragePlot:
                    name = 'erp_average'
                    label = 'ERP average plot'
                    source_name = 'valid_erp'

        TimeContainer:
            name = 'trial_plot_container'
            label = 'Trial timing'
            span = 2
            delay = 0.5

            ViewBox:
                name = 'ecg_view'
                y_min = -5
                y_max = 5

                ChannelPlot:
                    pen_color = 'k'
                    source_name = 'ecg'

            #ViewBox:
            #    name = 'microphone_view'
            #    y_min = 0
            #    y_max = 0.1
            #    y_mode = 'upper'

            #    ChannelPlot:
            #        pen_color = 'k'
            #        source_name = 'microphone_rms'
