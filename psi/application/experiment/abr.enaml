import logging
log = logging.getLogger(__name__)

from atom.api import Typed
import numpy as np

from enaml.application import deferred_call
from enaml.workbench.api import Extension
from enaml.workbench.core.api import Command

from psi.context.api import ContextGroup, Parameter, SequenceSelector
from psi.context.selector import CartesianProduct
from psi.context import choice
from psi.controller.api import EpochOutput, ExperimentAction

from psi.controller.output import QueuedEpochOutput
from psi.controller.input import ExtractEpochs, Input, Threshold, ITI, Edges, Blocked, Accumulate, RejectEpochs, IIRFilter

from psi.context.api import Result, ContextGroup
from psi.controller.base_manifest import BaseManifest

from psi.controller.queue import InterleavedFIFOSignalQueue

from psi.util import copy_declarative

from psi.data.plots import (PGTimeContainer, 
                            PGExtremesChannelPlot, 
                            PGEpochAverageGridContainer,
                            PGChannelPlot)

from psi.data.sinks.epoch_counter import EpochCounter

from psi.controller.calibration.tone import tone_calibration


def save_trial(event):
    '''
    Saves the trial
    '''
    core = event.workbench.get_plugin('enaml.workbench.core')
    metadata = []
    for epoch in event.parameters['data']:
        m = e['metadata'].copy()
        metadata.append(m)
    parameters = {'results': metadata}
    core.invoke_command('psi.data.process_trials', parameters)


def calibrate_output(event):
    # Load the plugins we'll need
    core = event.workbench.get_plugin('enaml.workbench.core')
    controller = event.workbench.get_plugin('psi.controller')

    p = event.parameters

    selector_name = p.get('selector_name', 'default')
    parameter_name = p.get('parameter_name', 'target_tone_frequency')
    parameters = {'item_name': parameter_name, 'iterator': selector_name}
    frequencies = core.invoke_command('psi.context.unique_values', parameters)
    frequencies = list(frequencies)

    # Get the configuration for the channels
    output_channel = controller.get_output(p['output_name']).channel
    input_channel = controller.get_input(p['input_name']).channel

    engine = copy_declarative(output_channel.engine, 
                              name='cal_engine',
                              hw_ao_monitor_period=1, 
                              hw_ai_monitor_period=0.1)
    copy_declarative(output_channel, name='output', parent=engine)
    copy_declarative(input_channel, name='input', parent=engine)

    log.debug('Calibrating {}'.format(p['output_name']))
    # Run the calibration and update the output with that calibration
    output_channel.calibration = tone_calibration(engine, frequencies)
    for frequency in frequencies:
        spl = output_channel.calibration.get_spl(frequency, 1)
        log.info('{:.2f} Hz & 1vrms is {:.2f} dB SPL'.format(frequency, spl))


enamldef ControllerManifest(BaseManifest): manifest:

    Extension:
        id = 'io'
        point = 'psi.controller.io'

        QueuedEpochOutput: output:
            name = 'target'
            label = 'Target'
            target_name = 'speaker_0'
            selector_name = 'default'
            queue = InterleavedFIFOSignalQueue(fs=output.fs)
            auto_decrement = False

        Blocked:
            duration = 0.1
            name = 'eeg'
            save = True
            source_name = 'eeg_channel'

            Accumulate:
                name = 'eeg_buffered'
                n = 100

                IIRFilter:
                    name = 'eeg_buffered_filtered'
                    N = 2
                    btype = 'bandpass'
                    ftype = 'butter'
                    f_highpass = 200
                    f_lowpass = 10000

                    ExtractEpochs: extract:
                        save = True
                        buffer_size = 50
                        epoch_size = 8.5e-3
                        queue = output.queue
                        delay = 47.5/extract.fs
                        name = 'erp'

                        RejectEpochs:
                            save = True
                            threshold = 2.5
                            name = 'valid_erp'

    Extension:
        id = 'selectors'
        point = 'psi.context.selectors'

        CartesianProduct:
            name = 'default'
            label = 'ABR sequence'

    Extension:
        id = 'passive_commands'
        point = 'enaml.workbench.core.commands'
        Command:
            id = 'psi.controller.save_trial'
            handler = save_trial
        Command:
            id = 'psi.controller.calibrate_output'
            handler = calibrate_output

    Extension:
        id = 'actions'
        point = 'psi.controller.actions'
        rank = 100

        # The order of actions for experiment_prepare is important. We need to
        # make sure that the calibration is run before the queue is prepared.
        # Once the queue is prepared, the calibration has been set for those
        # stimuli.
        #ExperimentAction:
        #    event = 'experiment_prepare'
        #    command = 'psi.controller.calibrate_output'
        #    kwargs = {
        #        'input_name': 'microphone',
        #        'output_name': 'target',
        #        'parameter_name': 'target_tone_frequency',
        #    }

        ExperimentAction:
            event = 'experiment_prepare'
            command = 'erp_average.prepare_grid'

        ExperimentAction:
            event = 'experiment_prepare'
            command = 'target.prepare_queue'

        ExperimentAction:
            event = 'erp_acquired'
            command = 'psi.controller.save_trial'

        ExperimentAction:
            event = 'valid_erp_acquired'
            command = 'target.decrement_key'

        ExperimentAction:
            event = 'target_complete'
            command = 'psi.controller.stop'

    Extension:
        id = 'sink'
        point = 'psi.data.sinks'

        EpochCounter:
            name = 'erp_counter'
            label = 'ERPs acquired'
            epoch_name = 'erp'

        EpochCounter:
            name = 'valid_erp_counter'
            label = 'Valid ERPs acquired'
            epoch_name = 'valid_erp'

    Extension:
        id = 'plots'
        point = 'psi.data.plots'

        PGEpochAverageGridContainer:
            name = 'erp_average'
            title = 'ERP average'
            source_name = 'valid_erp'

        PGTimeContainer:
            name = 'trial_plot_container' 
            title = 'Trial timing'
            span = 10

            PGExtremesChannelPlot:
                source_name = 'eeg'
