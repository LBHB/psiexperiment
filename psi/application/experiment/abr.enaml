import logging
log = logging.getLogger(__name__)

from atom.api import Typed
import numpy as np

from enaml.workbench.api import Extension
from enaml.workbench.core.api import Command

from psi.context.api import ContextGroup, Parameter
from psi.context.selector import CartesianProduct
from psi.controller.api import ExperimentAction
from psi.controller.base_manifest import BaseManifest
from psi.controller.calibration.tone import tone_calibration
from psi.controller.input import (ContinuousInput, ExtractEpochs, Input,
                                  Blocked, Accumulate, RejectEpochs, IIRFilter,
                                  Decimate)
from psi.controller.output import QueuedEpochOutput, EpochOutput
from psi.controller.queue import InterleavedFIFOSignalQueue

from psi.util import copy_declarative

from psi.data.plots import (TimeContainer, ChannelPlot, EpochAveragePlot,
                            ChannelPlot, ViewBox)
from psi.data.sinks.epoch_counter import EpochCounter

from psi.token.primitives import Cos2Envelope, Tone, BandlimitedNoise



def save_trial(event):
    '''
    Saves the trial
    '''
    core = event.workbench.get_plugin('enaml.workbench.core')
    metadata = []
    for epoch in event.parameters['data']:
        m = epoch['metadata'].copy()
        metadata.append(m)
    parameters = {'results': metadata}
    core.invoke_command('psi.data.process_trials', parameters)


def get_frequencies(event):
    core = event.workbench.get_plugin('enaml.workbench.core')
    selector_name = p.get('selector_name', 'default')
    parameter_name = p.get('parameter_name', 'target_tone_frequency')
    parameters = {'item_name': parameter_name, 'iterator': selector_name}
    frequencies = core.invoke_command('psi.context.unique_values', parameters)
    return list(frequencies)


def calibrate_channel(event):
    log.info('Calibrating {} for {} Hz'.format(p['output_name'], frequencies))
    controller = event.workbench.get_plugin('psi.controller')
    p = event.parameters

    # Find the channels
    ao_channel = controller.get_output(p['output_name']).channel
    ai_channel = controller.get_input(p['input_name']).channel

    # Get a list of planned frequencies
    frequencies = get_frequencies(event)

    # Run the calibration and update the output with that calibration
    result = tone_spl(engine, frequencies, gain=-40,
                      ao_channel_names=[ao_channel.name],
                      ai_channel_name=ai_channel.name)

    for frequency in frequencies:
        spl = ao_channel.calibration.get_spl(frequency, 1)
        log.info('{:.2f} Hz & 1vrms is {:.2f} dB SPL'.format(frequency, spl))


enamldef ControllerManifest(BaseManifest): manifest:

    Extension:
        id = 'tokens'
        point = 'psi.token.tokens'

        # The most standard stimuli
        Cos2Envelope:
            name = 'tone_burst'
            label = 'tone'
            Tone:
                pass

        # Continuous noise (if desired for masking purposes)
        BandlimitedNoise:
            pass

    Extension:
        id = 'io'
        point = 'psi.controller.io'

        ContinuousInput:
            name = 'microphone'
            source_name = 'microphone_channel'

        QueuedEpochOutput: output:
            name = 'target'
            label = 'Target'
            target_name = 'speaker_0'
            selector_name = 'default'
            queue = InterleavedFIFOSignalQueue(fs=output.fs, initial_delay=1)
            auto_decrement = False

        Decimate:
            q = 25
            name = 'ecg'
            save = True
            source_name = 'eeg_channel'

        Blocked:
            duration = 0.1
            name = 'eeg'
            save = True
            source_name = 'eeg_channel'

            Accumulate:
                name = 'eeg_buffered'
                n = 50

                IIRFilter:
                    name = 'eeg_buffered_filtered'
                    N = 2
                    btype = 'bandpass'
                    ftype = 'butter'
                    f_highpass = 200
                    f_lowpass = 10000

                    ExtractEpochs: extract:
                        save = True
                        buffer_size = 50
                        epoch_size = 8.5e-3
                        queue = output.queue
                        delay = 47.5/extract.fs
                        name = 'erp'

                        RejectEpochs:
                            save = True
                            threshold = 2.5
                            name = 'valid_erp'

    Extension:
        id = 'selectors'
        point = 'psi.context.selectors'

        CartesianProduct:
            name = 'default'
            label = 'ABR sequence'

    Extension:
        id = 'passive_commands'
        point = 'enaml.workbench.core.commands'
        Command:
            id = 'psi.controller.save_trial'
            handler = save_trial
        Command:
            id = 'psi.controller.calibrate_channel'
            handler = calibrate_channel

    Extension:
        id = 'actions'
        point = 'psi.controller.actions'
        rank = 100

        # The order of actions for experiment_prepare is important. We need to
        # make sure that the calibration is run before the queue is prepared.
        # Once the queue is prepared, the calibration has been set for those
        # stimuli.
        ExperimentAction:
            weight = 15
            event = 'experiment_prepare'
            command = 'psi.controller.calibrate_output'
            kwargs = {
                'input_name': 'microphone',
                'output_name': 'target',
                'parameter_name': 'target_tone_frequency',
            }

        ExperimentAction:
            event = 'erp_acquired'
            command = 'psi.controller.save_trial'

        ExperimentAction:
            event = 'valid_erp_acquired'
            command = 'target.decrement_key'

        ExperimentAction:
            event = 'target_end'
            command = 'psi.controller.stop'

    Extension:
        id = 'sink'
        point = 'psi.data.sinks'

        EpochCounter:
            name = 'valid_erp_counter'
            label = 'Valid ERPs acquired'
            epoch_name = 'valid_erp'

    Extension:
        id = 'plots'
        point = 'psi.data.plots'

        TimeContainer:
            name = 'erp_container'
            label = 'ERP average'
            span = 8.5e-3

            ViewBox:
                y_min = -0.1
                y_max = 0.1
                label = 'Signal (V)'

                EpochAveragePlot:
                    name = 'erp_average'
                    label = 'ERP average plot'
                    source_name = 'valid_erp'

        TimeContainer:
            name = 'trial_plot_container'
            label = 'Trial timing'
            span = 2

            ViewBox:
                y_min = -5
                y_max = 5

                ChannelPlot:
                    pen_color = 'k'
                    source_name = 'ecg'
