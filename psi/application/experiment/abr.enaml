import logging
log = logging.getLogger(__name__)

from atom.api import Typed
import numpy as np

from enaml.widgets.api import DockItem, Container
from enaml.workbench.api import Extension
from enaml.workbench.core.api import Command

from psi.core.enaml.editable_table_widget import DataFrameTable
from psi.context.api import (ContextGroup, Parameter, BoolParameter,
                             EnumParameter)
from psi.context.selector import CartesianProduct

from psi.controller import queue
from psi.controller.api import ExperimentAction
from psi.controller.base_plugin import BasePlugin
from psi.controller.base_manifest import BaseManifest
from psi.controller.input import (ContinuousInput, ExtractEpochs, Input,
                                  Blocked, Accumulate, RejectEpochs, IIRFilter,
                                  Decimate, Downsample)
from psi.controller.output import QueuedEpochOutput, EpochOutput
from psi.controller.output_manifest import add_setting_to_epoch_output
from psi.controller.queue import InterleavedFIFOSignalQueue

from psi.util import copy_declarative

from psi.data.plots import (TimeContainer, ChannelPlot,
                            StackedEpochAveragePlot, ChannelPlot, ViewBox)

from psi.data.sinks.epoch_counter import GroupedEpochCounter
from psi.data.sinks.bcolz_store import BColzStore

from psi.token.primitives import Cos2Envelope, Tone, BandlimitedNoise


from psi.controller.calibration import FlatCalibration


def configure_hardware(event):
    context = event.workbench.get_plugin('psi.context')
    controller = event.workbench.get_plugin('psi.controller')

    threshold = context.get_value('reject_threshold')
    ordering = context.get_value('ordering')
    alternate_polarity = context.get_value('alternate_polarity')
    tone_duration = context.get_value('target_tone_burst_duration')
    rate = context.get_value('rate')
    averages = context.get_value('averages')

    if alternate_polarity and (averages % 2):
        # Round to the nearest multiple of 2
        averages = (int(averages/2) + 1) * 2

    # Compensate for the tone duration. ITI is the time from tone offset to
    # tone offset.
    iti = 1/rate - tone_duration
    if iti <= 0:
        raise ValueError('Repetition rate is too fast')

    controller.set_input_attr('valid_erp', 'threshold', threshold)
    target = controller.get_output('target')

    # Configure the queues
    if ordering == 'interleaved':
        target.queue = queue.InterleavedFIFOSignalQueue()
    elif ordering == 'sequential':
        target.queue = queue.FIFOSignalQueue()
    else:
        raise ValueError('Unrecognized ordering {}'.format(ordering))

    if not alternate_polarity:
        for setting in context.iter_settings('default', 1):
            add_setting_to_epoch_output(setting, target, averages, iti)
    elif ordering == 'interleaved':
        for setting in context.iter_settings('default', 1):
            setting['output_tone_polarity'] = 1
            add_setting_to_epoch_output(setting, target, averages, iti)
        for setting in context.iter_settings('default', 1):
            setting['output_tone_polarity'] = -1
            add_setting_to_epoch_output(setting, target, averages, iti)
    elif ordering == 'sequential':
        for setting in context.iter_settings('default', 1):
            setting['output_tone_polarity'] = 1
            add_setting_to_epoch_output(setting, target, averages, iti)
            setting['output_tone_polarity'] = -1
            add_setting_to_epoch_output(setting, target, averages, iti)
    else:
        raise ValueError('Unrecognized ordering')


enamldef ControllerManifest(BaseManifest): manifest:

    Extension:
        id = 'data'
        point = 'psi.data.sinks'

        BColzStore:
            epoch_inputs = ['erp']
            continuous_inputs = ['eeg', 'temperature']

    Extension:
        id = 'tokens'
        point = 'psi.token.tokens'

        Cos2Envelope:
            name = 'tone_burst'
            label = 'tone'
            Tone:
                pass

    Extension:
        id = 'io'
        point = 'psi.controller.io'

        IIRFilter:
            source_name = 'temperature'
            f_lowpass = 0.1
            btype = 'lowpass'
            ftype = 'butter'
            N = 1

            Downsample:
                name = 'temperature_decimated'
                q = 50

        ContinuousInput:
            name = 'microphone'
            source_name = 'microphone_channel'

        QueuedEpochOutput: output:
            name = 'target'
            label = 'Target'
            target_name = 'speaker_0'
            auto_decrement = False

        ContinuousInput:
            name = 'eeg'
            source_name = 'eeg_channel'

        IIRFilter:
            name = 'eeg_filtered'
            N = 2
            btype = 'bandpass'
            ftype = 'butter'
            f_highpass = 300
            f_lowpass = 3000
            source_name = 'eeg_channel'

            ExtractEpochs: extract:
                name = 'erp'
                queue << output.queue
                epoch_size = 8.5e-3

                RejectEpochs:
                    name = 'valid_erp'
                    threshold = 0

    Extension:
        id = 'context'
        point = 'psi.context.items'

        ContextGroup:
            name = 'abr'
            label = 'ABR settings'

            Parameter:
                name = 'reject_threshold'
                label = 'Reject threshold'
                compact_label = 'Th'
                default = 2.5
                scope = 'experiment'

            Parameter:
                name = 'averages'
                label = 'Averages'
                default = 512
                scope = 'experiment'

            Parameter:
                name = 'rate'
                label = 'Reps. per sec.'
                default = 30
                scope = 'experiment'

            BoolParameter:
                name = 'alternate_polarity'
                label = 'Alternate polarity?'
                default = True
                scope = 'experiment'

            EnumParameter:
                name = 'ordering'
                label = 'Stimulus ordering'
                choices = {
                    'interleaved': '"interleaved"',
                    'sequential': '"sequential"',
                }
                scope = 'experiment'

    Extension:
        id = 'selectors'
        point = 'psi.context.selectors'

        CartesianProduct:
            name = 'default'
            label = 'ABR sequence'

    Extension:
        id = 'calibration_commands'
        point = 'enaml.workbench.core.commands'
        Command:
            id = 'psi.controller.configure_hardware'
            handler = configure_hardware

    Extension:
        id = 'actions'
        point = 'psi.controller.actions'
        rank = 100

        ExperimentAction:
            weight = 10
            event = 'experiment_prepare'
            command = 'psi.controller.tone_calibrate_channel'
            kwargs = {
                'input_name': 'microphone',
                'output_name': 'target',
                'parameter_names': ['target_tone_frequency'],
                'gain': -50,
                'max_thd': None,
                'min_snr': None,
                'duration': 0.1,
                'trim': 0.01,
                'iti': 0,
                'widget_name': 'calibration_result',
                'attr_name': 'result',
            }

        ExperimentAction:
            # Since this creates the queue, we need to make sure that the queue
            # gets configured after the calibration is performed.
            event = 'experiment_prepare'
            command = 'psi.controller.configure_hardware'
            weight = 15

        ExperimentAction:
            event = 'valid_erp_acquired'
            command = 'target.decrement_key'

        ExperimentAction:
            event = 'target_end'
            command = 'psi.controller.stop'

    Extension:
        id = 'sink'
        point = 'psi.data.sinks'

        GroupedEpochCounter:
            name = 'valid_erp_counter'
            label = 'Valid ERPs acquired'
            source_name = 'valid_erp'

    Extension:
        id = 'calibration_view'
        point = 'psi.experiment.workspace'

        DockItem: di:
            name = 'calibration_result'
            title = 'Calibration result'
            attr result = None

            Container:
                DataFrameTable:
                    column_info = {
                        'frequency': {'label': 'Frequency (Hz)'},
                        'snr': {'label': 'SNR (dB)'},
                        'thd': {'label': 'THD (%)'},
                        'norm_spl': {'label': 'SPL @ 1 Vrms'},
                    }
                    columns = ['frequency', 'norm_spl', 'snr', 'thd']
                    data << result


    Extension:
        id = 'plots'
        point = 'psi.data.plots'

        TimeContainer:
            name = 'temp_container'
            label = 'Temperature'
            span = 10*60

            ViewBox:
                y_min = 35
                y_max = 40
                label = 'Temperature (Celsius)'

                ChannelPlot:
                    source_name = 'temperature_decimated'

        TimeContainer:
            name = 'erp_container'
            label = 'ERP average'
            span = 8.5e-3

            ViewBox:
                y_min = -5
                y_max = 5
                label = 'Signal (V)'

                StackedEpochAveragePlot:
                    name = 'erp_average'
                    label = 'ERP average plot'
                    source_name = 'valid_erp'
                    n_update = 8
                    group_filter = lambda key: key['target_tone_level'] % 20 == 0
                    group_color_key = lambda key: key['target_tone_frequency']
                    pen_color_cycle = 'palettable.cartocolors.qualitative.Vivid_10'
                    pen_width = 2

        TimeContainer:
            name = 'trial_plot_container'
            label = 'Trial timing'
            span = 2
            delay = 0.125

            ViewBox:
                name = 'ecg_view'
                y_min = -5
                y_max = 5

                ChannelPlot:
                    name = 'eeg_filtered_plot'
                    pen_color = 'k'
                    source_name = 'eeg_filtered'
