import logging
log = logging.getLogger(__name__)

import enaml
from enaml.application import deferred_call
from enaml.core.api import Looper
from enaml.layout.api import InsertItem
from enaml.widgets.api import Action, ToolBar
from enaml.workbench.api import Extension, ExtensionPoint, PluginManifest
from enaml.workbench.core.api import Command
from enaml.workbench.ui.api import MenuItem

from psi.experiment.api import Preferences
from psi.context.api import ContextGroup
from psi.controller.calibration.tone import tone_sens
from psi.controller.calibration import PointCalibration

from ..util import rpc

from .base_plugin import BasePlugin
from .output import AnalogOutput, Toggle, Trigger
from .experiment_action import (ExperimentState, ExperimentEvent,
                                ExperimentAction)

from .output_manifest import ToggleManifest, TriggerManifest


def log_actions(event):
    plugin = event.workbench.get_plugin('psi.controller')

    accumulator = {}
    for action in plugin._actions:
        a = accumulator.setdefault(action.event, [])
        info = '{} (weight={})'.format(action.command, action.weight)
        a.append(info)

    lines = ['Configured actions']
    for event, actions in accumulator.items():
        lines.append(event)
        for action in actions:
            lines.append('\t' + action)
    log.info('\n'.join(lines))


def start_experiment(event):
    controller = event.workbench.get_plugin('psi.controller')
    controller.prepare_experiment()
    controller.start_experiment()


def get_hw_ao_choices(workbench):
    plugin = workbench.get_plugin('psi.controller')
    channels = plugin.get_channels('analog', 'output', 'hardware', False)
    return {c.label: '"{}"'.format(c.name) for c in channels}


def get_hw_ai_choices(workbench):
    plugin = workbench.get_plugin('psi.controller')
    channels = plugin.get_channels('analog', 'input', 'hardware', False)
    return {c.label: '"{}"'.format(c.name) for c in channels}


def tone_calibrate_channel(event):
    '''
    Calibrate the specified output using the specified input

    Useful for in-ear calibrations. The calibration will be saved.

    Parameters
    ----------
    output_name : string
        Output to calibrate
    input_name : string
        Input to calibrate
    selector_name : string (default='default')
        Selector to use
    parameter_name : string
        Parameter name that contains set of frequencies to calibrate at.
    gain : float
        Gain to set on output channel
    max_thd : {None, float}
        Maximum total harmonic distortion (in percent) to allow. Anything above
        this raises a calibration error.
    min_snr : {None, float}
        Minimum test level (re. noise floor). If the test tone is too close to
        the noise floor, this raises a calibration error.
    duration : float
        Duration of test tone
    iti : float
        Intertrial interval between test tones
    trim : float
        Amount to trim off of start and end of test tone response before
        analysis.
    widget_name : {None, string}
        Name of widget containing results set to update (for viewing).
    attr_name : {None, string}
        Name of attribute on widget to set.
    store_name : {None, string}
        Name of store to write data to.
    '''
    p = event.parameters
    controller = event.workbench.get_plugin('psi.controller')

    # Find the input and output to use for calibration
    ao = controller.get_output(p['output_name'])
    ai = controller.get_input(p['input_name'])

    # Get a list of planned frequencies
    core = event.workbench.get_plugin('enaml.workbench.core')
    parameter_names = event.parameters.get('parameter_names')
    selector_name = event.parameters.get('selector_name', 'default')

    frequencies = set()
    for parameter_name in parameter_names:
        parameters = {'item_name': parameter_name, 'iterator': selector_name}
        new = core.invoke_command('psi.context.unique_values', parameters)
        frequencies.update(new)

    frequencies = list(frequencies)

    # Run the calibration and update the output with that calibration
    result = tone_sens(ao.engine,
                       frequencies,
                       gain=p['gain'],
                       ao_channel_name=ao.channel.name,
                       ai_channel_names=[ai.channel.name],
                       max_thd=p['max_thd'],
                       min_snr=p['min_snr'],
                       duration=p['duration'],
                       iti=p['iti'],
                       trim=p['trim'])

    log.info('Calibration for output %s using input %s', ao.name, ai.name)
    log.info('\n' + str(result))

    result = result.reset_index()
    calibration = PointCalibration(result['frequency'], result['sens'])
    ao.channel.calibration = calibration

    for parameter in ('gain', 'max_thd', 'min_snr'):
        result[parameter] = p[parameter]

    if p.get('store_name') is not None:
        core = event.workbench.get_plugin('enaml.workbench.core')
        command = '{}.create_table'.format(p['store_name'])
        name = '{}_{}_calibration'.format(ao.name, ai.name)
        parameters = {'name': name, 'dataframe': result}
        core.invoke_command(command, parameters)

    if p.get('widget_name') is not None:
        ui = event.workbench.get_plugin('enaml.workbench.ui')
        widget = ui.window.find(p['widget_name'])
        attr_name = p.get('attr_name')
        setattr(widget, attr_name, result)


enamldef BaseManifest(PluginManifest): manifest:
    '''
    Defines the core functionality that most controller plugins will share
    (start, stop, pause, apply/revert settings).
    '''
    id = 'psi.controller'
    factory = BasePlugin

    ExtensionPoint:
        id = 'psi.controller.io'

    ExtensionPoint:
        id = 'psi.controller.actions'

    Extension:
        id = 'commands'
        point = 'enaml.workbench.core.commands'

        Command:
            id = 'psi.controller.start'
            handler = start_experiment
        Command:
            id = 'psi.controller.stop'
            handler = rpc('psi.controller', 'stop_experiment')

        Command:
            id = 'psi.controller.next_trial'
            handler = rpc('psi.controller', 'end_trial')
        Command:
            id = 'psi.controller.request_apply'
            handler = rpc('psi.controller', 'request_apply')
        Command:
            id = 'psi.controller.request_pause'
            handler = rpc('psi.controller', 'request_pause')
        Command:
            id = 'psi.controller.request_resume'
            handler = rpc('psi.controller', 'request_resume')
        Command:
            id = 'psi.controller.set_pause_ok'
            handler = rpc('psi.controller', 'set_pause_ok')

        Command:
            id = 'psi.controller.configure_engines'
            handler = rpc('psi.controller', 'configure_engines')
        Command:
            id = 'psi.controller.start_engines'
            handler = rpc('psi.controller', 'start_engines')
        Command:
            id = 'psi.controller.stop_engines'
            handler = rpc('psi.controller', 'stop_engines')
        Command:
            id = 'psi.controller.reset_engines'
            handler = rpc('psi.controller', 'reset_engines')
        Command:
            id = 'psi.controller.tone_calibrate_channel'
            handler = tone_calibrate_channel
        Command:
            id = 'psi.controller.log_actions'
            handler = log_actions

    # Uses unicode symbols as icons for sake of simplicity.
    Extension:
        id = 'toolbar'
        rank = 1
        point = 'psi.experiment.toolbar'

        ToolBar:
            Action:
                text = 'Start'
                tool_tip = 'Start experiment'
                triggered ::
                    plugin = workbench.get_plugin('enaml.workbench.core')
                    plugin.invoke_command('psi.controller.start')
                enabled << workbench.get_plugin('psi.controller').experiment_state \
                    == 'initialized'
            Action:
                text = 'Stop'
                tool_tip = 'Stop experiment'
                triggered ::
                    plugin = workbench.get_plugin('enaml.workbench.core')
                    plugin.invoke_command('psi.controller.stop')
                enabled <<  workbench.get_plugin('psi.controller').experiment_state \
                    not in ('initialized', 'stopped')
            Action:
                separator = True
            Action:
                text << 'Resume' if checked else 'Pause'
                checkable = True
                enabled << workbench.get_plugin('psi.controller')._pause_ok
                tool_tip << 'Resume' if checked else 'Pause'
                toggled ::
                    plugin = workbench.get_plugin('enaml.workbench.core')
                    if checked:
                        plugin.invoke_command('psi.controller.request_pause')
                    else:
                        plugin.invoke_command('psi.controller.request_resume')
            Action:
                separator = True

            # Apply/Revert logic should pass through the controller so we can
            # ensure that the changes occur at the appropriate time in a trial
            # (i.e., in between trials). 
            Action:
                text = 'Apply'
                enabled << workbench.get_plugin('psi.context').changes_pending \
                    and not workbench.get_plugin('psi.controller')._apply_requested \
                    and workbench.get_plugin('psi.controller').experiment_state \
                    in ('running', 'paused')
                triggered :: 
                    plugin = workbench.get_plugin('enaml.workbench.core')
                    plugin.invoke_command('psi.controller.request_apply')
            #Action:
            #    text = 'Revert'
            #    enabled << workbench.get_plugin('psi.context').changes_pending \
            #        and workbench.get_plugin('psi.controller').experiment_state \
            #        in ('running', 'paused')
            #    triggered :: 
            #        plugin = workbench.get_plugin('enaml.workbench.core')
            #        plugin.invoke_command('psi.context.revert_changes')

    Extension:
        id = 'base_menu'
        point = 'enaml.workbench.ui.actions'
        MenuItem:
            path = '/equipment'
            label = 'Equipment'
            after = 'configuration'
        MenuItem:
            path = '/equipment/output'
            label = 'Outputs'

    Extension:
        id = 'base_actions'
        point = 'psi.controller.actions'
        rank = 10

        ExperimentState:
            name = 'experiment'
        ExperimentEvent:
            name = 'engines_configured'

        ExperimentAction:
            event = 'experiment_prepare'
            command = 'psi.controller.configure_engines'
        ExperimentAction:
            event = 'experiment_start'
            command = 'psi.controller.start_engines'
        ExperimentAction:
            event = 'experiment_end'
            command = 'psi.controller.stop_engines'
        ExperimentAction:
            event = 'plugins_started'
            command = 'psi.controller.log_actions'
