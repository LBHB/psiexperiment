import logging
log =  logging.getLogger(__name__)

from functools import partial

import numpy as np

from atom.api import Typed, Property

from enaml.core.api import d_, Looper, Include
from enaml.workbench.api import Extension
from enaml.workbench.core.api import Command
from enaml.workbench.ui.api import ActionItem, MenuItem, ItemGroup

from psi.context.api import ContextGroup, Parameter
from psi.experiment.api import ItemPreferences

from psi.core.enaml.api import PSIManifest
from .experiment_action import ExperimentState, ExperimentEvent


class OutputManifest(PSIManifest): 

    output = Property()

    def _get_output(self):
        return self.contribution

    def _set_output(self, value):
        self.contribution = value


def toggle_off(event, output):
    output.set_low()


def toggle_on(event, output):
    output.set_high()


def fire(event, output):
    output.fire()


def toggle(event, output):
    if event.parameters['state']:
        toggle_on(event, output)
    else:
        toggle_off(event, output)


def set_token(event, output, output_type):
    token_plugin = event.workbench.get_plugin('psi.token')
    factory = getattr(token_plugin, 'generate_{}_token'.format(output_type))
    token = factory(event.parameters['token_name'], output.name, output.label)
    output.token = token
    output.token_name = event.parameters['token_name']

    # TODO: This is a hack. Maybe?
    context_plugin = event.workbench.get_plugin('psi.context')
    context_plugin._refresh_items()


def prepare_output(event, output):
    core = event.workbench.get_plugin('enaml.workbench.core')
    context = core.invoke_command('psi.context.get_values')
    output.setup(context)


def prepare_output_queue(event, output):
    controller = event.workbench.get_plugin('psi.controller')
    context = event.workbench.get_plugin('psi.context')
    iterable = context.iter_settings(output.selector_name, 1)
    action_name = output.name + '_complete'
    complete_cb = partial(controller.invoke_actions, action_name)
    output.setup(iterable, complete_cb)


def start_output(event, output):
    ts = event.parameters['timestamp']
    start = event.parameters.get('start', ts)
    delay = event.parameters.get('delay', 0)
    duration = output.start(start, delay)

    controller = event.workbench.get_plugin('psi.controller')
    controller.invoke_actions('{}_start'.format(output.name), start+delay)
    controller.invoke_actions('{}_end'.format(output.name),
                              start+delay+duration, delayed=True)


def clear_output(event, output):
    end = event.parameters['timestamp']
    delay = event.parameters.get('delay', 0)
    output.clear(end, delay)
    controller = event.workbench.get_plugin('psi.controller')
    controller.invoke_actions('{}_end'.format(output.name), end+delay)

    
def decrement_key(event, output):
    for epoch in event.parameters['data']:
        try:
            output.queue.decrement_key(epoch['key'])
        except KeyError:
            m = 'Acquired extra epoch for {}'
            log.debug(m.format(epoch['key']))


enamldef AnalogOutputManifest(OutputManifest): manifest:

    Extension:
        id = 'output_commands'
        point = 'enaml.workbench.core.commands'
        Command:
            id = manifest.output.name + '.set_token'
            handler = partial(set_token, output=manifest.output,
                              output_type=output_type)
        Command:
            id = manifest.output.name + '.prepare'
            handler = partial(prepare_output, output=manifest.output)
        Command:
            id = manifest.output.name + '.start'
            handler = partial(start_output, output=manifest.output)
        Command:
            id = manifest.output.name + '.clear'
            handler = partial(clear_output, output=manifest.output)

    Extension:
        id = 'output_menu.' + manifest.output.name
        point = 'enaml.workbench.ui.actions'
        MenuItem:
            path = '/equipment/output/{}'.format(manifest.output.name)
            label = '{} ({})'.format(manifest.output.label, output_type)
            ItemGroup:
                exclusive = True
                id = manifest.output.name
        Looper:
            # Provide this in the subclass
            iterable << tokens.values()
            ActionItem:
                path = '/equipment/output/{}/{}'.format(manifest.output.name, 
                                                        loop_item.name)
                label << loop_item.label
                group = manifest.output.name
                command = manifest.output.name + '.set_token'
                checked << manifest.output.token_name == loop_item.name
                checkable = True
                parameters = {'token_name': loop_item.name}
                enabled << workbench.get_plugin('psi.controller').experiment_state \
                    in ('initialized', 'stopped')

    Extension:
        # For some reason this doesn't get loaded if it's lumped together with
        # the following extension, so I've split them out. Not sure why. Some
        # exception is getting swallowed silently.
        id = 'groups.' + manifest.output.name
        point = 'psi.context.items'
        ContextGroup:
            name = manifest.output.name
            label = manifest.output.label

    Extension:
        id = 'items.' + manifest.output.name
        point = 'psi.context.items'
        Include:
            # list provides an empty list of context items if needed.
            objects << getattr(manifest.output.token, 'get_context_items',
                               list)()

    Extension:
        id = 'actions.' + manifest.output.name
        point = 'psi.controller.actions'
        ExperimentState:
            name = manifest.output.name

    Extension:
        id = 'preferences.' +  manifest.output.name
        point = 'psi.experiment.preferences'
        rank = 10
        ItemPreferences:
            name = 'output.' + manifest.output.name
            item = manifest.output
            auto_save = ['token_name']
            set_preferences => (workbench, preferences):
                # Override the set_preferences since we need to loop into the
                # token generation machinery. The output does not have access
                # to this plugin. TODO This is a hack. I'm sure I'll figure out a
                # better approach eventually.
                core = workbench.get_plugin('enaml.workbench.core')
                command = manifest.output.name + '.set_token'
                core.invoke_command(command, parameters=preferences)


enamldef EpochOutputManifest(AnalogOutputManifest): manifest:

    attr tokens = workbench.get_plugin('psi.token')._epoch_tokens
    attr output_type = 'epoch'


enamldef QueuedEpochOutputManifest(EpochOutputManifest): manifest:

    Extension:
        id = 'actions'
        point = 'psi.controller.actions'
        ExperimentEvent:
            name = manifest.output.name + '_complete'

    Extension:
        id = 'commands'
        point = 'enaml.workbench.core.commands'
        Command:
            id = manifest.output.name + '.prepare_queue'
            handler = partial(prepare_output_queue, output=manifest.output)
        Command:
            id = manifest.output.name + '.decrement_key'
            handler = partial(decrement_key, output=manifest.output)

    Extension:
        id = 'items'
        point = 'psi.context.items'

        ContextGroup:
            name = manifest.output.name + '_sequence'
            label = manifest.output.label + ' epoch settings'

            Parameter:
                name = manifest.output.name + '_iti_duration'
                label = manifest.output.label + ' intertrial interval (s)'
                compact_label = manifest.output.label + ' ITI'
                default = 0.1
                scope = 'experiment'

            Parameter:
                name = manifest.output.name + '_averages'
                label = manifest.output.label + ' averages'
                compact_label = manifest.output.label + ' N'
                default = 1
                scope = 'experiment'



enamldef ContinuousOutputManifest(AnalogOutputManifest): manifest:

    attr tokens = workbench.get_plugin('psi.token')._continuous_tokens
    attr output_type = 'continuous'


enamldef ToggleManifest(OutputManifest): manifest:

    Extension:
        id = 'toggle_commands.' + manifest.output.name
        point = 'enaml.workbench.core.commands'
        Command:
            id = manifest.id + '.off'
            handler = partial(toggle_off, output=manifest.output)
        Command:
            id = manifest.id + '.on'
            handler = partial(toggle_on, output=manifest.output)
        Command:
            id = manifest.id + '.toggle'
            handler = partial(toggle, output=manifest.output)

    Extension:
        id = 'toggle_actions.' + manifest.output.name
        point = 'enaml.workbench.ui.actions'
        ActionItem:
            path = '/equipment/{}'.format(manifest.output.name)
            label = '{}'.format(manifest.output.label)
            command = manifest.id + '.toggle'
            parameters << {'state': checked}
            checked << manifest.output.state
            checkable = True
            status_tip = command


enamldef TriggerManifest(OutputManifest): manifest:

    Extension:
        id = 'trigger_commands'
        point = 'enaml.workbench.core.commands'
        Command:
            id = manifest.id + '.trigger'
            handler = partial(fire, output=manifest.output)

    Extension:
        id = 'trigger_actions'
        point = 'enaml.workbench.ui.actions'
        ActionItem:
            path = '/equipment/{}'.format(manifest.output.name)
            label = '{} trigger'.format(manifest.output.label)
            command = manifest.id + '.trigger'
            status_tip = command
