import logging
log = logging.getLogger(__name__)

import numpy as np

from psi.context.api import Parameter

from .block import Block
from .primitives import single_input


@single_input
def default_continuous_factory(fs, input):
    waveform = None
    offset = 0
    while True:
        kwargs = (yield waveform)
        kwargs['offset'] = offset
        waveform = input.send(kwargs)
        offset += len(waveform)


enamldef Token(Block):
    pass


@single_input
def default_epoch_factory(fs, duration, input):
    # This is responsible for generating the waveform when the appropriate
    # offset is reached. Here, start_ts and offset are specified re the master
    # clock. The master clock is referenced to the *start* of the experiment.
    # Once the token is complete (e.g.e, epoch duration is met), the generator
    # terminates.
    waveform = None
    epoch_samples = int(duration*fs)

    m = 'Initializing epoch factory with duration {}'
    log.debug(m.format(epoch_samples))

    while True:
        kwargs = (yield waveform)
        offset = kwargs['offset']
        samples = kwargs['samples']
        log.debug('Generating {} samples at {}'.format(samples, offset))
        n_remaining = np.clip(samples, 0, epoch_samples)

        if offset >= epoch_samples:
            break

        # If we still have samples we need to generate, pull them from the
        # actual token generator (adjust offset and samles accordingly).
        kwargs['offset'] = offset
        kwargs['samples'] = n_remaining
        m = 'Generating {} token samples at {}'
        log.debug(m.format(kwargs['samples'], kwargs['offset']))
        waveform = input.send(kwargs)


enamldef EpochToken(Token):

    name = 'epoch'
    label = 'epoch'
    factory = default_epoch_factory

    Parameter:
        name = 'duration'
        label = 'duration (s)'
        compact_label = 'dur'
        dtype = np.dtype('float32')
        default = 4
        expression = '4'


enamldef ContinuousToken(Token):

    factory = default_continuous_factory
