from __future__ import division

import logging
log = logging.getLogger(__name__)

import numpy as np
from scipy import signal
from joblib import Memory

from psi import get_config
from psi.context.api import Parameter, EnumParameter

from .block import Block

memory = Memory(cachedir=get_config('TEMP_ROOT'))


################################################################################
# Utility
################################################################################
def single_input(function):
    def wrapper(*args, **kwargs):
        inputs = kwargs.pop('inputs')
        if len(inputs) == 0:
            raise ValueError('Cannot deal with 0 inputs')
        elif len(inputs) > 1:
            raise ValueError('Cannot deal with more than one input')
        kwargs['input'] = inputs[0] 
        return function(*args, **kwargs)
    return wrapper


def no_inputs(function):
    def wrapper(*args, **kwargs):
        inputs = kwargs.pop('inputs')
        if len(inputs) != 0:
            raise ValueError('Cannot accept inputs')
        return function(*args, **kwargs)
    return wrapper


################################################################################
# Cos2Envelope
################################################################################
#@memory.cache
def cos2envelope(t, start_time, rise_time, duration):
    '''
    Generates cosine-squared envelope. Can handle generating fragments.
    '''
    def env_func(t, phi=0):
        return np.sin(2*np.pi*t*1.0/rise_time*0.25+phi)**2

    m_null_pre = (t < start_time)
    m_onset = (t >= start_time) & (t < rise_time)

    # If duration is set to infinite, than we only apply an *onset* ramp.
    # This is used, in particular, for the DPOAE stimulus in which we want
    # to ramp on a continuous tone and then play it continuously until we
    # acquire a sufficient number of epochs.
    if duration != np.inf:
        m_offset = (t >= (start_time+duration-rise_time)) & \
            (t < (start_time+duration))
        m_null_post = t >= (duration+start_time)
    else:
        m_offset = np.zeros_like(t, dtype=np.bool)
        m_null_post = np.zeros_like(t, dtype=np.bool)

    t_null_pre = t[m_null_pre]
    t_onset = t[m_onset]
    t_offset = t[m_offset]
    t_ss = t[~(m_null_pre | m_onset | m_offset | m_null_post)]
    t_null_post = t[m_null_post]

    f_null_pre = np.zeros(len(t_null_pre))
    f_lower = env_func(t_onset, 0)
    f_upper = env_func(t_offset-(duration-rise_time), np.pi/2)
    f_middle = np.ones(len(t_ss))
    f_null_post = np.zeros(len(t_null_post))
    envelope = np.r_[f_null_pre, f_lower, f_middle, f_upper, f_null_post]
    return envelope


@single_input
def cos2envelope_factory(fs, start_time, rise_time, duration, calibration,
                         input, infinite=True):
    # We provide the infinite argument so that the behavior of this can be
    # modified slightly to work with an EpochOutput.
    waveform = None
    epoch_samples = np.inf if infinite else int(duration*fs)
    while True:
        kwargs = (yield waveform)
        samples = kwargs['samples']
        offset = kwargs['offset']
        if offset >= epoch_samples:
            break
        t = (np.arange(samples, dtype=np.float32) + offset)/fs
        envelope = cos2envelope(t, start_time, rise_time, duration)
        token = input.send(kwargs)
        waveform = envelope*token


enamldef Cos2Envelope(Block): block:

    factory = cos2envelope_factory
    name = 'envelope'
    label = 'envelope'

    Parameter:
        name = 'duration'
        label = 'duration (s)'
        compact_label = 'dur'
        default = 4.0

    Parameter:
        name = 'rise_time'
        label = 'rise time (s)'
        compact_label = 'env rise'
        default = 1.0

    Parameter:
        name = 'start_time'
        label = 'start time (s)'
        compact_label = 'start'
        default = 0.0


################################################################################
# SAM envelope
################################################################################
@memory.cache
def sam_eq_power(depth):
    return (3.0/8.0*depth**2.0-depth+1.0)**0.5


@memory.cache
def sam_eq_phase(delay, depth, direction):
    if depth == 0:
        return 0
    z = 2.0/depth*sam_eq_power(depth)-2.0/depth+1
    phi = np.arccos(z)
    return 2.0*np.pi-phi if direction == 1 else phi


@memory.cache
def sam_envelope(offset, samples, fs, depth, fm, delay, direction):
    eq_phase = sam_eq_phase(delay, depth, direction)
    eq_power = sam_eq_power(depth)

    delay_n = np.clip(int(delay*fs)-offset, 0, samples)
    sam_n = samples-delay_n

    sam_offset = offset-delay_n
    t = (np.arange(sam_n, dtype=np.float32) + sam_offset)/fs
    sam_envelope = depth/2.0*np.cos(2.0*np.pi*fm*t+eq_phase)+1.0-depth/2.0

    # Ensure that we scale the waveform so that the total power remains equal
    # to that of an unmodulated token.
    sam_envelope *= 1.0/eq_power

    delay_envelope = np.ones(delay_n)
    return np.concatenate((delay_envelope, sam_envelope))


@single_input
def samenvelope_factory(fs, depth, fm, delay, direction, calibration, input):
    waveform = None
    while True:
        kwargs = (yield waveform)
        samples = kwargs['samples']
        offset = kwargs['offset']
        log.debug('generating SAM envelope with %d samples', samples) 
        env = sam_envelope(offset, samples, fs, depth, fm, delay, direction)
        token = input.send(kwargs)
        waveform = env*token


enamldef SAMEnvelope(Block): block:

    factory = samenvelope_factory
    name = 'SAM'
    label = 'SAM'

    Parameter:
        name = 'depth'
        label = 'depth (frac.)'
        compact_label = 'depth'
        default = 1.0

    Parameter:
        name = 'fm'
        label = 'Modulation frequency (Hz)'
        compact_label = 'fm'
        default = 5.0

    Parameter:
        name = 'delay'
        label = 'AM delay (s)'
        compact_label = 'delay'
        default = 0.0

    EnumParameter:
        name = 'direction'
        label = 'Initial AM direction'
        compact_label = 'dir'
        default = 'positive'
        choices = {'positive': 1, 'negative': -1}


################################################################################
# Broadband noise
################################################################################
@no_inputs
def noise_factory(fs, seed, level, calibration):
    waveform = None
    state = np.random.RandomState(seed)
    while True:
        kwargs = (yield waveform)
        samples = kwargs['samples']
        waveform = state.uniform(low=-1, high=1, size=samples)
        # TODO: figure out how to scale waveform to target level


enamldef Noise(Block):
    
    factory = noise_factory
    name = 'noise'
    label = 'noise'

    Parameter:
        name = 'level'
        label = 'level (dB SPL)'
        compact_label = 'level'
        default = 60.0

    Parameter:
        name = 'seed'
        label = 'random seed'
        compact_label = 'seed'
        default = 1


################################################################################
# Bandlimited noise
################################################################################
@memory.cache
def _calculate_bandlimited_noise_filter(fs, center_frequency, pass_bandwidth,
                                        stop_bandwidth, passband_attenuation,
                                        stopband_attenuation):
    fl = center_frequency-0.5*pass_bandwidth
    fh = center_frequency+0.5*pass_bandwidth
    Wp = np.array([fl, fh])/(0.5*fs)
    fl = center_frequency-0.5*stop_bandwidth
    fh = center_frequency+0.5*stop_bandwidth
    Ws = np.array([fl, fh])/(0.5*fs)
    b, a = signal.iirdesign(Wp, Ws, passband_attenuation, stopband_attenuation) 
    zi = signal.lfilter_zi(b, a)
    return b, a, zi


@memory.cache
def _calculate_bandlimited_noise_iir(fs, calibration, center_frequency,
                                     pass_bandwidth):
    fl = center_frequency-0.5*pass_bandwidth
    fh = center_frequency+0.5*pass_bandwidth
    duration = 2.0/fl
    iir = calibration.get_iir(fs, fl, fh, duration)
    zi = signal.lfilter_zi(iir, [1])
    return iir, zi


@no_inputs
def bandlimited_noise_factory(fs, seed, level, center_frequency,
                              pass_bandwidth, stop_bandwidth,
                              passband_attenuation, stopband_attenuation,
                              calibration):
    waveform = None
    state = np.random.RandomState(seed)

    sf = calibration.get_sf(center_frequency, level)
    
    b, a, bp_zi = _calculate_bandlimited_noise_filter(
        fs, center_frequency, pass_bandwidth, stop_bandwidth,
        passband_attenuation, stopband_attenuation)

    iir, iir_zi = _calculate_bandlimited_noise_iir(
        fs, calibration, center_frequency, pass_bandwidth)

    # This was copied from the EPL CFT. Need to figure out how this equation
    # works so we can document this better. But it works as intended to scale
    # the noise back to RMS=1.
    filter_sf = 1.0/np.sqrt(pass_bandwidth*2/fs/3.0)

    # The RMS value of noise drawn from a uniform distribution is
    # amplitude/sqrt(3). By setting the low and high to sqrt(3) and multiplying
    # by the scaling factors, we can ensure that the noise is initially
    # generated with the desired RMS.
    low, high = -np.sqrt(3)*filter_sf*sf, np.sqrt(3)*filter_sf*sf

    while True:
        kwargs = (yield waveform)
        samples = kwargs['samples']
        log.debug('generating bandlimited noise with %d samples', samples)
        waveform = state.uniform(low=low, high=high, size=samples)
        waveform, iir_zi = signal.lfilter(iir, [1], waveform, zi=iir_zi)
        waveform, bp_zi = signal.lfilter(b, a, waveform, zi=bp_zi)


enamldef BandlimitedNoise(Block):
    
    factory = bandlimited_noise_factory
    name = 'bandlimited_noise'
    label = 'bandlimited noise'

    Parameter:
        name = 'level'
        label = 'level (dB SPL)'
        compact_label = 'level'
        default = 60.0

    Parameter:
        name = 'seed'
        label = 'random seed'
        compact_label = 'seed'
        default = 1

    Parameter:
        name = 'center_frequency'
        label = 'center frequency (Hz)'
        compact_label = 'fc'
        default = 8000.0

    Parameter:
        name = 'pass_bandwidth'
        label = 'pass bandwidth (Hz)'
        compact_label = 'pass bw'
        default = 6000.0

    Parameter:
        name = 'stop_bandwidth'
        label = 'stop bandwidth (Hz)'
        compact_label = 'stop bw'
        default = 4000.0

    Parameter:
        name = 'passband_attenuation'
        label = 'passband attenuation (dB)'
        compact_label = 'pass. atten.'
        default = 10.0

    Parameter:
        name = 'stopband_attenuation'
        label = 'stopband attenuation (dB)'
        compact_label = 'stop. atten.'
        default = 60.0


################################################################################
# Bandpass filter
################################################################################
@single_input
def bandpass_filter_factory(fs, center_frequency, pass_bandwidth,
                            stop_bandwidth, passband_attenuation,
                            stopband_attenuation, calibration, input):
    waveform = None

    fl = np.clip(center_frequency-0.5*pass_bandwidth, 0, 0.5*fs)
    fh = np.clip(center_frequency+0.5*pass_bandwidth, 0, 0.5*fs)
    Wp = np.array([fl, fh])/(0.5*fs)

    fl = np.clip(center_frequency-0.5*stop_bandwidth, 0, 0.5*fs)
    fh = np.clip(center_frequency+0.5*stop_bandwidth, 0, 0.5*fs)
    Ws = np.array([fl, fh])/(0.5*fs)

    b, a = signal.iirdesign(Wp, Ws, passband_attenuation, stopband_attenuation) 

    if not np.all(np.abs(np.roots(a)) < 1):
        raise ValueError, 'Instable coefficients for filter'

    zf = signal.lfilter_zi(b, a)

    # I haven't taken the time to understand this equation, but it seems to
    # work.  This was copied from the EPL cochlear function test suite code
    # (LabVIEW) and should renormalize the amplitude of the filtered token so
    # it has a RMS of 1.0.
    filter_sf = 1.0/np.sqrt(pass_bandwidth*2/fs/3.0)

    while True:
        kwargs = (yield waveform)
        noise_token = input.send(kwargs)
        filtered_token, zf = signal.lfilter(b, a, noise_token, zi=zf)
        # TODO HACK ALERT!!! SF fix needed.
        waveform = filter_sf*filtered_token


enamldef BandpassFilter(Block):

    factory = bandpass_filter_factory
    name = 'filter'
    label = 'filter'

    Parameter:
        name = 'center_frequency'
        label = 'center frequency (Hz)'
        compact_label = 'fc'
        default = 8000.0

    Parameter:
        name = 'pass_bandwidth'
        label = 'pass bandwidth (Hz)'
        compact_label = 'pass bw'
        default = 6000.0

    Parameter:
        name = 'stop_bandwidth'
        label = 'stop bandwidth (Hz)'
        compact_label = 'stop bw'
        default = 4000.0

    Parameter:
        name = 'passband_attenuation'
        label = 'passband attenuation (dB)'
        compact_label = 'pass. atten.'
        default = 10.0

    Parameter:
        name = 'stopband_attenuation'
        label = 'stopband attenuation (dB)'
        compact_label = 'stop. atten.'
        default = 60.0


################################################################################
# Tone
################################################################################
@no_inputs
def tone_factory(fs, level, frequency, calibration):
    waveform = None
    sf = calibration.get_sf(frequency, level)
    while True:
        kwargs = (yield waveform)
        samples = kwargs['samples']
        offset = kwargs['offset']
        t = np.arange(samples, dtype=np.float32)/fs + offset
        waveform = sf*np.cos(2*np.pi*t*frequency)


enamldef Tone(Block):

    factory = tone_factory
    name = 'tone'
    label = 'tone'

    Parameter:
        name = 'level'
        label = 'level (dB SPL)'
        compact_label = 'level'
        default = 60.0

    Parameter:
        name = 'frequency'
        label = 'frequency (Hz)'
        compact_label = 'fc'
        default = 1000.0


@no_inputs
def silence_factory(fs, calibration):
    waveform = None
    while True:
        kwargs = (yield waveform)
        samples = kwargs['samples']
        waveform = np.zeros(samples)


################################################################################
# Silence
################################################################################
enamldef Silence(Block):

    factory = silence_factory
    name = 'silence'
    label = 'silence'
