from __future__ import division

import logging
log = logging.getLogger(__name__)

import numpy as np
from scipy import signal
from joblib import Memory

from psi import get_config
from psi.context.api import Parameter, EnumParameter

from .block import Block

# NOTE: For some functions, it's better not to cache as there is a "hit" from
# checking whether to load the results from disk or not.
cachedir = get_config('TEMP_ROOT')
memory = Memory(cachedir=cachedir, mmap_mode='r')


################################################################################
# Utility
################################################################################
def single_input(function):
    def wrapper(*args, **kwargs):
        input_factories = kwargs.pop('input_factories')
        if len(input_factories) == 0:
            raise ValueError('Cannot deal with zero input factories')
        elif len(input_factories) > 1:
            raise ValueError('Cannot deal with more than one input factory')
        return function(*args, input_factory=input_factories[0], **kwargs)
    return wrapper


def no_inputs(function):
    def wrapper(*args, **kwargs):
        input_factories = kwargs.pop('input_factories')
        if len(input_factories) != 0:
            raise ValueError('Cannot accept any input factories')
        return function(*args, **kwargs)
    return wrapper


################################################################################
# Cos2Envelope
################################################################################
def cos2envelope(fs, offset, samples, start_time, rise_time, duration):
    '''
    Generates cosine-squared envelope. Can handle generating fragments.
    '''
    def env_func(t, phi=0):
        return np.sin(2*np.pi*t*1.0/rise_time*0.25+phi)**2

    t = (np.arange(samples, dtype=np.float32) + offset)/fs

    m_null_pre = (t < start_time)
    m_onset = (t >= start_time) & (t < rise_time)

    # If duration is set to infinite, than we only apply an *onset* ramp.
    # This is used, in particular, for the DPOAE stimulus in which we want
    # to ramp on a continuous tone and then play it continuously until we
    # acquire a sufficient number of epochs.
    if duration != np.inf:
        m_offset = (t >= (start_time+duration-rise_time)) & \
            (t < (start_time+duration))
        m_null_post = t >= (duration+start_time)
    else:
        m_offset = np.zeros_like(t, dtype=np.bool)
        m_null_post = np.zeros_like(t, dtype=np.bool)

    t_null_pre = t[m_null_pre]
    t_onset = t[m_onset]
    t_offset = t[m_offset]
    t_ss = t[~(m_null_pre | m_onset | m_offset | m_null_post)]
    t_null_post = t[m_null_post]

    f_null_pre = np.zeros(len(t_null_pre))
    f_lower = env_func(t_onset, 0)
    f_upper = env_func(t_offset-(duration-rise_time), np.pi/2)
    f_middle = np.ones(len(t_ss))

    concat = [f_null_pre, f_lower, f_middle, f_upper]
    return np.concatenate(concat, axis=-1)


@single_input
def cos2envelope_factory(fs, start_time, rise_time, duration, calibration,
                         input_factory):
    # Initialize some variables 
    waveform = None
    epoch_samples = int(duration*fs)
    offset = 0
    complete = False

    # Initialize the inputs
    input_generator = input_factory()
    input_generator.next()

    while True:
        # Provide waveform and wait on instructions for next waveform
        kwargs = (yield waveform, complete)

        # Ensure we don't produce more samples than needed to complete waveform
        samples = kwargs['samples']
        samples = min(epoch_samples-offset, samples)
        kwargs['samples'] = samples

        # Generate the waveform
        envelope = cos2envelope(fs, offset, samples, start_time, rise_time,
                                duration)
        token = input_generator.send(kwargs)
        waveform = envelope*token
        offset += len(waveform)

        # Check if we're done
        if offset == epoch_samples:
            complete = True
        elif offset > epoch_samples:
            raise ValueError('Algorithm mistake!!')
        else:
            complete = False


enamldef Cos2Envelope(Block): block:

    factory = cos2envelope_factory
    name = 'envelope'
    label = 'envelope'

    Parameter:
        name = 'duration'
        label = 'duration (s)'
        compact_label = 'dur'
        default = 4.0

    Parameter:
        name = 'rise_time'
        label = 'rise time (s)'
        compact_label = 'env rise'
        default = 1.0

    Parameter:
        name = 'start_time'
        label = 'start time (s)'
        compact_label = 'start'
        default = 0.0


################################################################################
# Pregenerate samples
################################################################################
def pregenerate_samples(wrapped, fs, **kwargs):
    block_size = int(10*fs)
    input = wrapped(fs=fs, **kwargs)
    input.next()
    cached, complete = input.send({'samples': block_size})
    waveform = None
    complete = False

    while True:
        samples = kwargs['samples']
        kwargs = (yield waveform, complete)
        if len(cached) < samples:
            c, complete = input.send({'samples': block_size})
            cached = np.concatenate([cached, c])
        waveform = cached[:samples]
        cached = cached[samples:]


################################################################################
# SAM envelope
################################################################################
@memory.cache
def sam_eq_power(depth):
    return (3.0/8.0*depth**2.0-depth+1.0)**0.5


@memory.cache
def sam_eq_phase(delay, depth, direction):
    if depth == 0:
        return 0
    z = 2.0/depth*sam_eq_power(depth)-2.0/depth+1
    phi = np.arccos(z)
    return 2.0*np.pi-phi if direction == 1 else phi


@memory.cache
def sam_envelope(offset, samples, fs, depth, fm, delay, direction):
    eq_phase = sam_eq_phase(delay, depth, direction)
    eq_power = sam_eq_power(depth)

    delay_n = np.clip(int(delay*fs)-offset, 0, samples)
    sam_n = samples-delay_n

    sam_offset = offset-delay_n
    t = (np.arange(sam_n, dtype=np.float32) + sam_offset)/fs
    sam_envelope = depth/2.0*np.cos(2.0*np.pi*fm*t+eq_phase)+1.0-depth/2.0

    # Ensure that we scale the waveform so that the total power remains equal
    # to that of an unmodulated token.
    sam_envelope *= 1.0/eq_power

    delay_envelope = np.ones(delay_n)
    return np.concatenate((delay_envelope, sam_envelope))


@single_input
def samenvelope_factory(fs, depth, fm, delay, direction, calibration,
                        input_factory):
    waveform = None
    offset = 0

    # Initialize the inputs
    input_generator = input_factory()
    input_generator.next()

    while True:
        kwargs = (yield waveform)
        samples = kwargs['samples']
        env = sam_envelope(offset, samples, fs, depth, fm, delay, direction)
        token = input_generator.send(kwargs)
        waveform = env*token
        offset += len(waveform)


enamldef SAMEnvelope(Block): block:

    factory = samenvelope_factory
    name = 'SAM'
    label = 'SAM'

    Parameter:
        name = 'depth'
        label = 'depth (frac.)'
        compact_label = 'depth'
        default = 1.0

    Parameter:
        name = 'fm'
        label = 'Modulation frequency (Hz)'
        compact_label = 'fm'
        default = 5.0

    Parameter:
        name = 'delay'
        label = 'AM delay (s)'
        compact_label = 'delay'
        default = 0.0

    EnumParameter:
        name = 'direction'
        label = 'Initial AM direction'
        compact_label = 'dir'
        default = 'positive'
        choices = {'positive': 1, 'negative': -1}


################################################################################
# Bandlimited noise
################################################################################
@memory.cache
def _calculate_bandlimited_noise_filter(fs, center_frequency, pass_bandwidth,
                                        stop_bandwidth, passband_attenuation,
                                        stopband_attenuation):
    fl = center_frequency-0.5*pass_bandwidth
    fh = center_frequency+0.5*pass_bandwidth
    Wp = np.array([fl, fh])/(0.5*fs)
    fl = center_frequency-0.5*stop_bandwidth
    fh = center_frequency+0.5*stop_bandwidth
    Ws = np.array([fl, fh])/(0.5*fs)
    b, a = signal.iirdesign(Wp, Ws, passband_attenuation, stopband_attenuation) 
    zi = signal.lfilter_zi(b, a)
    return b, a, zi


@memory.cache
def _calculate_bandlimited_noise_iir(fs, calibration, center_frequency,
                                     pass_bandwidth):
    fl = center_frequency-0.5*pass_bandwidth
    fh = center_frequency+0.5*pass_bandwidth
    duration = 2.0/fl
    iir = calibration.get_iir(fs, fl, fh, duration)
    zi = signal.lfilter_zi(iir, [1])
    return iir, zi


@no_inputs
def bandlimited_noise_factory(fs, seed, level, center_frequency,
                              pass_bandwidth, stop_bandwidth,
                              passband_attenuation, stopband_attenuation,
                              calibration):
    waveform = None
    state = np.random.RandomState(seed)

    sf = calibration.get_sf(center_frequency, level)
    
    b, a, bp_zi = _calculate_bandlimited_noise_filter(
        fs, center_frequency, pass_bandwidth, stop_bandwidth,
        passband_attenuation, stopband_attenuation)

    iir, iir_zi = _calculate_bandlimited_noise_iir(
        fs, calibration, center_frequency, pass_bandwidth)

    # This was copied from the EPL CFT. Need to figure out how this equation
    # works so we can document this better. But it works as intended to scale
    # the noise back to RMS=1.
    filter_sf = 1.0/np.sqrt(pass_bandwidth*2/fs/3.0)

    # The RMS value of noise drawn from a uniform distribution is
    # amplitude/sqrt(3). By setting the low and high to sqrt(3) and multiplying
    # by the scaling factors, we can ensure that the noise is initially
    # generated with the desired RMS.
    low, high = -np.sqrt(3)*filter_sf*sf, np.sqrt(3)*filter_sf*sf

    while True:
        kwargs = (yield waveform)
        samples = kwargs['samples']
        waveform = state.uniform(low=low, high=high, size=samples)
        waveform, iir_zi = signal.lfilter(iir, [1], waveform, zi=iir_zi)
        waveform, bp_zi = signal.lfilter(b, a, waveform, zi=bp_zi)


enamldef BandlimitedNoise(Block):
    
    factory = bandlimited_noise_factory
    name = 'bandlimited_noise'
    label = 'bandlimited noise'

    Parameter:
        name = 'level'
        label = 'level (dB SPL)'
        compact_label = 'level'
        default = 60.0

    Parameter:
        name = 'seed'
        label = 'random seed'
        compact_label = 'seed'
        default = 1

    Parameter:
        name = 'center_frequency'
        label = 'center frequency (Hz)'
        compact_label = 'fc'
        default = 8000.0

    Parameter:
        name = 'pass_bandwidth'
        label = 'pass bandwidth (Hz)'
        compact_label = 'pass bw'
        default = 6000.0

    Parameter:
        name = 'stop_bandwidth'
        label = 'stop bandwidth (Hz)'
        compact_label = 'stop bw'
        default = 4000.0

    Parameter:
        name = 'passband_attenuation'
        label = 'passband attenuation (dB)'
        compact_label = 'pass. atten.'
        default = 10.0

    Parameter:
        name = 'stopband_attenuation'
        label = 'stopband attenuation (dB)'
        compact_label = 'stop. atten.'
        default = 60.0


################################################################################
# Tone
################################################################################
@no_inputs
def tone_factory(fs, level, frequency, calibration):
    sf = calibration.get_sf(frequency, level)
    waveform = None
    offset = 0
    while True:
        # Note. At least for 5 msec tones it's faster to just compute the array
        # rather than cache the result.
        kwargs = (yield waveform)
        samples = kwargs['samples']
        t = np.arange(samples, dtype=np.float32)/fs + offset
        waveform = np.cos(2*np.pi*t*frequency)
        offset += len(waveform)


enamldef Tone(Block):

    factory = tone_factory
    name = 'tone'
    label = 'tone'

    Parameter:
        name = 'level'
        label = 'level (dB SPL)'
        compact_label = 'level'
        default = 60.0

    Parameter:
        name = 'frequency'
        label = 'frequency (Hz)'
        compact_label = 'fc'
        default = 1000.0


@no_inputs
def silence_factory(fs, calibration):
    waveform = None
    while True:
        kwargs = (yield waveform)
        samples = kwargs['samples']
        waveform = np.zeros(samples)


################################################################################
# Silence
################################################################################
enamldef Silence(Block):

    factory = silence_factory
    name = 'silence'
    label = 'silence'
