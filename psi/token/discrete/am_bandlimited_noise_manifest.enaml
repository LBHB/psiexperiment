from __future__ import division

import numpy as np
from scipy import signal

from atom.api import Atom, Typed, Bool, Float, Property
from enaml.workbench.api import Extension

from ..api import TokenManifest, TokenPlugin
from psi.context.api import Parameter, EnumParameter

from backports import inspect


def from_context(f):
    signature = inspect.signature(f)
    parameters = set(signature.parameters.keys())
    parameters.remove('self')

    def wrapper(self, *args, **kwargs):
        bound = signature.bind_partial(*args, **kwargs)
        bound_parameters = set(bound.arguments.keys())
        missing = parameters.difference(bound_parameters)
        for parameter in missing:
            if hasattr(self, '_get_{}'.format(parameter)):
                kwargs[parameter] = getattr(self, '_get_{}'.format(parameter))()
            elif hasattr(self, parameter):
                kwargs[parameter] = getattr(self, parameter)
            else:
                kwargs[parameter] = self.get_context_item(parameter)
        bound = signature.bind_partial(*args, **kwargs)
        return f(self, *bound.args, **bound.kwargs)

    return wrapper


def sam_eq_power(depth):
    return (3.0/8.0*depth**2-depth+1)**0.5


def sam_eq_phase(delay, depth, direction):
    if depth == 0:
        return 0
    z = 2.0/depth*sam_eq_power(depth)-2.0/depth+1
    phi = np.arccos(z)
    return 2*np.pi-phi if direction == 1 else phi


def cos2envelope(t, start_time, rise_time, duration):
    def env_func(t, phi=0):
        return np.sin(2*np.pi*t*1.0/rise_time*0.25+phi)**2

    m_null_pre = (t < start_time)
    m_onset = (t >= start_time) & (t < rise_time)

    # If duration is set to infinite, than we only apply an *onset* ramp.
    # This is used, in particular, for the DPOAE stimulus in which we want
    # to ramp on a continuous tone and then play it continuously until we
    # acquire a sufficient number of epochs.
    if duration != np.inf:
        m_offset = (t >= (start_time+duration-rise_time)) & \
            (t < (start_time+duration))
        m_null_post = t >= (duration+start_time)
    else:
        m_offset = np.zeros_like(t, dtype=np.bool)
        m_null_post = np.zeros_like(t, dtype=np.bool)

    t_null_pre = t[m_null_pre]
    t_onset = t[m_onset]
    t_offset = t[m_offset]
    t_ss = t[~(m_null_pre | m_onset | m_offset | m_null_post)]
    t_null_post = t[m_null_post]

    f_null_pre = np.zeros(len(t_null_pre))
    f_lower = env_func(t_onset, 0)
    f_upper = env_func(t_offset-(duration-rise_time), np.pi/2)
    f_middle = np.ones(len(t_ss))
    f_null_post = np.zeros(len(t_null_post))
    envelope = np.r_[f_null_pre, f_lower, f_middle, f_upper, f_null_post]
    return envelope


class AMBandlimitedNoisePlugin(TokenPlugin):

    ########################################################################
    # Methods for computing/caching waveform
    ########################################################################
    fs = Float()
    time = Property
    noise_token = Property
    filter_coefficients = Property
    filtered_noise_token = Property
    sam_envelope = Property

    @from_context
    def _get_time(self, fs, duration):
        samples = int(fs*duration)
        return np.arange(samples, dtype=np.float32)/fs
        
    @from_context
    def _get_noise_token(self, time, seed):
        state = np.random.RandomState(seed)
        return state.uniform(low=-1, high=1, size=len(time))

    @from_context
    def _get_filter_coefficients(self, fs, center_frequency, pass_bandwidth,
                                 stop_bandwidth, passband_attenuation,
                                 stopband_attenuation):

        fl = np.clip(center_frequency-0.5*pass_bandwidth, 0, 0.5*fs)
        fh = np.clip(center_frequency+0.5*pass_bandwidth, 0, 0.5*fs)
        Wp = np.array([fl, fh])/(0.5*fs)

        fl = np.clip(center_frequency-0.5*stop_bandwidth, 0, 0.5*fs)
        fh = np.clip(center_frequency+0.5*stop_bandwidth, 0, 0.5*fs)
        Ws = np.array([fl, fh])/(0.5*fs)
        return signal.iirdesign(Wp, Ws, passband_attenuation,
                                stopband_attenuation) 

    @from_context
    def _get_filtered_noise_token(self, filter_coefficients, noise_token):
        b, a = filter_coefficients
        token = signal.filtfilt(b, a, noise_token)

        # TODO: LOOK AT THIS!  This renormalizes the noise token after being
        # filtered.  It would also make sense to scale up the waveform to
        # MAX_VRMS (e.g. MAX_VRMS = get_config('MAX_SPEAKER_DAC_VOLTAGE'))
        token = token/np.mean(token**2)**0.5
        return token

    @from_context
    def _get_eq_phase(self, sam_onset, sam_depth, sam_direction):
        return sam_eq_phase(sam_onset, sam_depth, sam_direction)

    @from_context
    def _get_eq_power(self, sam_depth):
        return sam_eq_power(sam_depth)

    @from_context
    def _get_sam_envelope(self, fs, time, eq_phase, eq_power, sam_frequency,
                          sam_depth, sam_onset):
        envelope = sam_depth/2*np.cos(2*np.pi*sam_frequency*time+eq_phase)+1-sam_depth/2

        # Ensure that we scale the waveform so that the total power remains
        # equal to that of an unmodulated token.
        envelope *= 1.0/eq_power

        delay_n = int(sam_onset*fs)
        if delay_n > 0:
            delay_envelope = np.ones(delay_n)
            envelope = np.concatenate((delay_envelope, envelope[:-delay_n]))
        return envelope

    @from_context
    def _get_cos_envelope(self, time, rise_time, duration):
        return cos2envelope(time, 0, rise_time, duration)

    @from_context
    def get_token(self, cos_envelope, sam_envelope, filtered_noise_token):
        return cos_envelope*sam_envelope*filtered_noise_token

    #########################################################################
    ## Actual waveform computation
    #########################################################################
    #def compute_waveform(self, calibration, hw_attenuation=0):
    #    # Compute the required attenuation 
    #    level = self.get_current_value('level')
    #    fc = self.get_current_value('fc')

    #    # This is the SPL that will come out of the speaker for a 1 Vrms pure
    #    # tone at the center frequency of the noise.  This is a very rough proxy
    #    # for generating noise at the desired spectrum level in lieu of a better
    #    # calibration using an equalized speaker and/or waveform that
    #    # compensates for inconsistent speaker output across the frequency
    #    # range.
    #    # 
    #    # Since the calibration data was most likely generated using a 3 Vrms
    #    # tone, calibration.get_spl will look up the SPL value for a 3 Vrms tone
    #    # (let's assume it's 130 dB SPL).  Then, the next step is to compute the
    #    # expected difference in output between a 1 Vrms and 3 Vrms tone.  Given
    #    #
    #    #   -9.54 dB = 20*log10(1./3.)
    #    #
    #    # The 1 Vrms tone will be 9.54 dB quieter than the 3 Vrms tone assuming
    #    # all other settings are the same (e.g. the hardware attenuation is the
    #    # same).  This means a 1 Vrms tone will generate ~120 dB SPL at 0 dB
    #    # attenuation (calibration.get_spl returns the expected SPL given 0 dB
    #    # of attenuation).
    #    spl = calibration.get_spl(fc, voltage=1)

    #    # We now know that a 1 Vrms tone will generate 120 dB SPL; however, we
    #    # want our level to be 85 dB SPL, so we need to attenuate the waveform
    #    # by 120-85 = 35 dB.
    #    attenuation = spl-level

    #    log.debug('Speaker output %.2f dB SPL at %.2f Hz using %.2f Vrms', 
    #              spl, fc, 1)
    #    log.debug('Need %.2f dB attenuation to achieve %.2f dB SPL',
    #              attenuation, level)

    #    # Get the cached waveforms.  Always use the self._get_waveform_name() methods
    #    # rather than self._waveform_name because the self._get_waveform_name()
    #    # method will check to see if the waveform needs to be recomputed.  If
    #    # the waveform does not need to be recomputed, the cached value will be
    #    # returned.
    #    #
    #    # Here, self._get_filtered_noise_token() has normalized the waveform to
    #    # and the 1 Vrms waveform 
    #    # 1 Vrms (which is what we assumed would be the value when determining
    #    # the attenuation in the steps above).  Now, we could upscale the
    #    # waveform if we wanted, e.g.:
    #    #
    #    #   waveform = waveform * 6
    #    #
    #    # Since the waveform was 1 Vrms before, it will now be 6 Vrms.  This
    #    # means that we need to compensate for this.
    #    #
    #    #   20*log10(6/1.) = 15.56 dB
    #    #
    #    # This means that the noise token will now be 16 dB louder than we had
    #    # assumed when computing the attenuation.  So, if we were to do this, we
    #    # would need to add 16 dB to the attenuation:
    #    #
    #    #   attenuation = attenuation + 16
    #    #
    #    # The reason we would want to make the Vrms larger and increase the
    #    # hardware attenuation accordingly is to compensate for "noise" that's
    #    # inherent in the DAC output.  The assumption is that the DAC output has
    #    # a higher noise-floor than the output of the hardware attenuator.  We
    #    # should amke sure that the min/max of the output (Voltage peak-to-peak)
    #    # is never > 10 otherwise it may clip.  Since the DAC has a maximum
    #    # output of +/- 10 Volts and the 1 Vrms waveform 
    #    token_sf = self.token_scaling_factor
    #    token = self._get_filtered_noise_token() * token_sf
    #    sam_envelope = self._get_sam_envelope()
    #    cos_envelope = self._get_cos_envelope()

    #    log.debug('Scaling waveform so it has %f Vrms', token_sf)

    #    # Compensate attenuation for the token scaling factor
    #    compensation = 20*np.log10(token_sf/1.)
    #    attenuation = attenuation + compensation

    #    log.debug('Increasing attenuation by %f to compensate', compensation)
    #    log.debug('Attenuation is now %f', attenuation)

    #    # Note that the parent class (AbstractPositiveController.trigger_next)
    #    # will handle splitting the attenuation into a hardware portion (e.g.
    #    # steps of 0, 20, 40, 60) and software portion.  The waveform will then
    #    # be scaled to achieve the software portion before getting uploaded to
    #    # the DSP buffer.  If you wanted to handle the logic of setting the
    #    # hardware attenuation and scaling the waveform appropriately, you can
    #    # do so in this function and return a value of None for the waveform
    #    # attenuation.  If trigger_next() recieves a value of None, then it will
    #    # not touch the hardware attenuation or scale the waveform.
    #    #
    #    # Very important!  You should use the method
    #    # self.set_attenuations(primary, secondary) to set the hardware
    #    # attenuators since the attenuation approach may depend on the circuit
    #    # (e.g. some circuits use the AudioOut macro, some don't).  
    #    waveform = token*sam_envelope*cos_envelope
    #    log.debug('Waveform spans %f to %f volts (peak to peak)',
    #              waveform.min(), waveform.max())
    #    return waveform, attenuation

    def initialize(self, fs):
        # Force a precomputation of the token to cache as much as possible
        self.fs = fs
        token = self.get_token()
        #import pylab as pl
        #pl.plot(token, 'k-')
        #pl.plot(env, 'r-')
        #pl.plot(sam, 'g-')
        #pl.show()
        #c = InterpCalibration.from_spl([0, 100e3], [100, 100])
        #channel = Channel(calibration=c,
        #                  token=carrier, voltage_min=-10, voltage_max=10)

    def get_waveform(self, offset, samples):
        if samples is not None:
            return self.get_token()[offset:offset+samples]
        else:
            return self.get_token()[offset:]


enamldef AMBandlimitedNoiseManifest(TokenManifest): m:

    id = 'token.bandlimited_noise.{}'.format(m.base)
    factory = lambda base=m.base: AMBandlimitedNoisePlugin(base=base)

    Extension:
        id = '{}_items'.format(m.id)
        point = 'psi.context.items'

        Parameter:
            name = '{}_duration'.format(m.base)
            label = '{} duration (s)'.format(m.label_base)
            compact_label = '{} dur'.format(m.compact_base)
            dtype = np.dtype('float32')
            default = 4
            expression = '4'
            group = m.base
            scope = m.scope

        Parameter:
            name = '{}_level'.format(m.base)
            label = '{} level (dB SPL)'.format(m.label_base)
            compact_label = '{} level'.format(m.compact_base)
            dtype = np.dtype('float32')
            default = 60
            expression = '60'
            group = m.base
            scope = m.scope

        Parameter:
            name = '{}_center_frequency'.format(m.base)
            label = '{} center frequency (Hz)'.format(m.label_base)
            compact_label = '{} fc'.format(m.compact_base)
            dtype = np.dtype('float32')
            default = 4000
            expression = '4000'
            group = m.base
            scope = m.scope

        Parameter:
            name = '{}_pass_bandwidth'.format(m.base)
            label = '{} pass bandwidth (Hz)'.format(m.label_base)
            compact_label = '{} pass bw'.format(m.compact_base)
            dtype = np.dtype('float32')
            default = 2000
            expression = '2000'
            group = m.base
            scope = m.scope

        Parameter:
            name = '{}_stop_bandwidth'.format(m.base)
            label = '{} stop bandwidth (Hz)'.format(m.label_base)
            compact_label = '{} stop bw'.format(m.compact_base)
            dtype = np.dtype('float32')
            default = 4000
            expression = '4000'
            group = m.base
            scope = m.scope

        Parameter:
            name = '{}_passband_attenuation'.format(m.base)
            label = '{} passband attenuation (dB)'.format(m.label_base)
            compact_label = '{} pass. atten.'.format(m.compact_base)
            dtype = np.dtype('float32')
            default = 1
            expression = '1'
            group = m.base
            scope = m.scope

        Parameter:
            name = '{}_stopband_attenuation'.format(m.base)
            label = '{} stopband attenuation (dB)'.format(m.label_base)
            compact_label = '{} stop. atten.'.format(m.compact_base)
            dtype = np.dtype('float32')
            default = 80
            expression = '80'
            group = m.base
            scope = m.scope

        Parameter:
            name = '{}_seed'.format(m.base)
            label = '{} random seed'.format(m.label_base)
            compact_label = '{} seed'.format(m.compact_base)
            dtype = np.dtype('float32')
            default = 1
            expression = '1'
            group = m.base
            scope = m.scope

        # cos2envelope parameters
        Parameter:
            name = '{}_rise_time'.format(m.base)
            label = '{} envelope rise time (s)'.format(m.label_base)
            compact_label = '{} env rise'.format(m.compact_base)
            dtype = np.dtype('float32')
            default = 1
            expression = '1'
            group = m.base
            scope = m.scope

        # AM parameters
        Parameter:
            name = '{}_sam_depth'.format(m.base)
            label = '{} SAM depth (frac.)'.format(m.label_base)
            compact_label = '{} SAM depth'.format(m.compact_base)
            dtype = np.dtype('float32')
            default = 1
            expression = '1'
            group = m.base
            scope = m.scope

        Parameter:
            name = '{}_sam_frequency'.format(m.base)
            label = '{} SAM frequency (Hz)'.format(m.label_base)
            compact_label = '{} SAM freq'.format(m.compact_base)
            dtype = np.dtype('float32')
            default = 5
            expression = '5'
            group = m.base
            scope = m.scope

        Parameter:
            name = '{}_sam_onset'.format(m.base)
            label = '{} SAM onset (s)'.format(m.label_base)
            compact_label = '{} SAM onset'.format(m.compact_base)
            dtype = np.dtype('float32')
            default = 0.3
            expression = '0.3'
            group = m.base
            scope = m.scope

        EnumParameter:
            name = '{}_sam_direction'.format(m.base)
            label = '{} SAM direction'.format(m.label_base)
            compact_label = '{} SAM dir.'.format(m.compact_base)
            dtype = np.dtype('int8')
            group = m.base
            scope = m.scope
            default = 'positive'
            choices = {'positive': 1, 'negative': -1}
