import logging
log = logging.getLogger(__name__)

import numpy as np
import pandas as pd
from scipy.stats import norm

from atom.api import ContainerList, Typed, Str, Int, observe, Bool
from enaml.application import deferred_call
from enaml.layout.api import InsertItem, hbox, vbox, spacer
from enaml.widgets.api import (Container, DockItem, CheckBox, Label, Field, HGroup)
from enaml.workbench.api import Extension, PluginManifest

from psi.core.utils import find_extension
from psi.core.enaml.dataframe_table_widget \
    import DataframeTable
from ..plugin import Sink

PLUGIN_ID = 'psi.data.sdt_analysis'

EXTRA_COLS = {
    'mean': 'Fraction', 
    'size': '# trials',
    'sum': '# Correct',
    'z_score': 'd\'',
}


class SDTAnalysis(Sink):

    trial_log = Typed(pd.DataFrame)
    results = Typed(pd.DataFrame)
    grouping = Typed(list, [])
    visible_columns = Typed(list, [])
    context_info = Typed(dict, {})

    limit = Int()
    include_repeat_nogo = Bool()
    include_go_remind = Bool()

    def prepare(self, plugin):
        if self.grouping:
            return
        g = [c for c, i in plugin.context_info.items() if getattr(i, 'rove', False)]
        self.grouping = ['trial_type'] + g

    def context_info_updated(self, context_info):
        context_info = {n: i.compact_label for n, i in context_info.items()}
        context_info.update(EXTRA_COLS)
        self.context_info = context_info

    def trial_log_updated(self, trial_log):
        self.trial_log = trial_log
        self.update_results()

    @observe('limit')
    def limit_changed(self, event):
        self.update_results()

    @observe('include_repeat_nogo')
    def include_repeat_nogo_changed(self, event):
        self.update_results()

    @observe('include_go_remind')
    def include_go_remind_changed(self, event):
        self.update_results()

    @observe('grouping')
    def grouping_changed(self, event):
        self.visible_columns = self.grouping + \
            ['mean', 'size', 'sum', 'z_score']

    def update_results(self):
        if self.trial_log is None:
            return
        if not self.grouping:
            return

        trial_log = self.trial_log.iloc[-self.limit:].copy()
        if self.include_repeat_nogo:
            m = trial_log.trial_type == 'nogo_repeat'
            trial_log.loc[m, 'trial_type'] = 'nogo'
        if self.include_go_remind:
            m = trial_log.trial_type == 'go_remind'
            trial_log.loc[m, 'trial_type'] = 'go'

        m = trial_log.trial_type.apply(lambda x: x in ('nogo', 'go'))
        if not np.any(m):
            return

        agg = ['sum', 'size', 'mean']
        r = trial_log[m].groupby(self.grouping)['correct'].agg(agg)
        r['z_score'] = r['mean'].clip(lower=0.05, upper=0.95).apply(norm.ppf)

        # Attempt to correct for the FA rate. If there is no NOGO, then assume
        # the FA rate is 0.05 (which corresponds to a "correct" rate of 0.95.
        try:
            r['z_score'] += r.loc['nogo', 'z_score'].iloc[0]
        except:
            r['z_score'] += norm.ppf(0.95)
        self.results = r.astype(np.float32).reset_index()


enamldef SDTAnalysisDockItem(DockItem):

    attr analysis

    Container:
        constraints = [
            vbox(
                hbox(
                    limit_label,
                    limit_field,
                    spacer,
                    repeat_nogo_field,
                    go_remind_field,
                ),
                table,
            )
        ]

        Label: limit_label:
            text = 'Trial limit'
            hug_width = 'strong'
        Field: limit_field:
            text << str(analysis.limit)
            text ::
                analysis.limit = int(text)
        CheckBox: repeat_nogo_field:
            checked := analysis.include_repeat_nogo
            text = 'Include repeat NOGO?'
        CheckBox: go_remind_field:
            checked := analysis.include_go_remind
            text = 'Include reminders?'

        DataframeTable: table:
            dataframe << analysis.results
            columns << analysis.visible_columns
            column_info << analysis.context_info


def contribute_to_workspace(workbench, workspace):
    extension = find_extension(workbench, PLUGIN_ID, 'sink', SDTAnalysis)
    item = SDTAnalysisDockItem(workspace.dock_area, analysis=extension,
                               name='sdt_analysis', title='SDT Analysis')
    op = InsertItem(item=item.name, position='right')
    deferred_call(workspace.dock_area.update_layout, op)


enamldef SDTAnalysisManifest(PluginManifest): manifest:

    id = PLUGIN_ID

    Extension:
        id = 'sink'
        point = 'psi.data.sink'
        SDTAnalysis:
            pass

    Extension:
        id = 'workspace'
        point = 'psi.experiment.workspace'
        factory = contribute_to_workspace
